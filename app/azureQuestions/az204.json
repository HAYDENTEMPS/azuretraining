{
  "meta": {
    "title": "AZ-204 Ultimate Practice (With Tips) – JSON Pack",
    "count": 100,
    "notes": "Domains per Microsoft blueprint. 100 questions. multi_select=true when multiple answers are required. Last updated: 2025-09-22"
  },
  "schema": {
    "id": "integer",
    "domain": "Compute | Storage | Security | Monitoring | Integration | IaaS",
    "question": "string",
    "options": [
      "A) ...",
      "B) ...",
      "C) ...",
      "D) ..."
    ],
    "multi_select": "boolean",
    "hint": "string",
    "correct_answers": [
      "A",
      "C"
    ],
    "explanation": "string"
  },
  "questions": [
    {
      "id": 1,
      "domain": "Compute",
      "question": "Which plan avoids cold starts while still auto scaling?",
      "options": [
        "A) Consumption",
        "B) Premium",
        "C) Dedicated",
        "D) Docker Hub"
      ],
      "multi_select": false,
      "hint": "Premium has pre-warmed instances.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Premium Functions plan avoids cold starts by keeping pre-warmed instances available while still supporting automatic scaling. The Consumption plan can scale elastically but experiences cold starts, and Dedicated plans require fixed VM instances. Premium provides the balance of elasticity and predictable performance."
    },
    {
      "id": 2,
      "domain": "Storage",
      "question": "Which Cosmos DB feature supports reactive change processing?",
      "options": [
        "A) Triggers",
        "B) Change Feed",
        "C) RU throttling",
        "D) Table API"
      ],
      "multi_select": false,
      "hint": "Change Feed is correct.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Cosmos DB Change Feed continuously streams inserts and updates in near real time, enabling event-driven processing and analytics pipelines. Triggers only fire on individual operations, RU throttling is about capacity limits, and the Table API is a different data model and does not provide change streams."
    },
    {
      "id": 3,
      "domain": "Security",
      "question": "Which OAuth2 flow should a SPA use?",
      "options": [
        "A) Client Credentials",
        "B) Auth Code + PKCE",
        "C) Device Code",
        "D) Implicit"
      ],
      "multi_select": false,
      "hint": "SPA must use Auth Code with PKCE.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Single-page applications (SPAs) should use the OAuth2 Authorization Code flow with PKCE, which adds security against token interception. Implicit flow is deprecated for SPAs, Client Credentials is for daemon apps, and Device Code is for devices with limited input capability."
    },
    {
      "id": 4,
      "domain": "Monitoring",
      "question": "Which Azure tool provides synthetic availability tests?",
      "options": [
        "A) Application Insights",
        "B) Log Analytics",
        "C) Traffic Manager",
        "D) Load Balancer"
      ],
      "multi_select": false,
      "hint": "App Insights availability tests.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Application Insights provides synthetic availability tests that continuously ping your app from various regions to monitor uptime and responsiveness. Log Analytics is used for querying telemetry, Traffic Manager distributes DNS traffic, and Load Balancer manages network traffic but does not perform synthetic testing."
    },
    {
      "id": 5,
      "domain": "Integration",
      "question": "Which service is best for massive telemetry ingestion?",
      "options": [
        "A) Service Bus",
        "B) Event Hubs",
        "C) Event Grid",
        "D) Storage Queue"
      ],
      "multi_select": false,
      "hint": "Event Hubs is for telemetry.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Event Hubs is designed for massive telemetry ingestion, supporting millions of events per second with partitioning for scalability. Service Bus is for enterprise workflows and guaranteed delivery, Event Grid is for lightweight event routing, and Storage Queues provide basic message queuing."
    },
    {
      "id": 6,
      "domain": "IaaS",
      "question": "Which IaC tool compiles to ARM JSON?",
      "options": [
        "A) Terraform",
        "B) Bicep",
        "C) Ansible",
        "D) Chef"
      ],
      "multi_select": false,
      "hint": "Bicep transpiles to ARM.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Bicep is the domain-specific language that transpiles into ARM JSON templates, making infrastructure-as-code authoring simpler. Terraform is cross-cloud but does not compile to ARM directly, Ansible and Chef are configuration management tools, not Azure-native IaC compilers."
    },
    {
      "id": 7,
      "domain": "Compute",
      "question": "Which feature allows staged deployments with no downtime?",
      "options": [
        "A) Slots",
        "B) Scaling",
        "C) App Service Environment",
        "D) Traffic Manager"
      ],
      "multi_select": false,
      "hint": "Slots support zero downtime.",
      "correct_answers": [
        "A"
      ],
      "explanation": "App Service Deployment Slots enable staged deployments with zero downtime, supporting blue-green or canary releases. Scaling adds capacity but doesn’t stage deployments, App Service Environments provide isolation, and Traffic Manager distributes traffic across endpoints but not between slots."
    },
    {
      "id": 8,
      "domain": "Storage",
      "question": "Which two blob features provide recovery from delete/overwrite?",
      "options": [
        "A) Soft Delete",
        "B) Versioning",
        "C) CORS",
        "D) CDN"
      ],
      "multi_select": true,
      "hint": "Soft Delete + Versioning.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "Blob Storage supports both Soft Delete and Versioning to recover accidentally deleted or overwritten data. CORS configures cross-origin requests and CDN accelerates content delivery, but neither provides data recovery."
    },
    {
      "id": 9,
      "domain": "Security",
      "question": "Which feature allows app to access Key Vault without secrets?",
      "options": [
        "A) Managed Identity",
        "B) Shared Secret",
        "C) IP Firewall",
        "D) RBAC only"
      ],
      "multi_select": false,
      "hint": "Managed Identity recommended.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Managed Identity allows applications to authenticate securely to Key Vault and other Azure resources without storing credentials in code. Shared Secrets, IP Firewalls, or RBAC alone do not provide the same seamless, secretless integration."
    },
    {
      "id": 10,
      "domain": "Monitoring",
      "question": "Which feature provides code-level snapshot debugging in production?",
      "options": [
        "A) Snapshot Debugger",
        "B) NSG logs",
        "C) Azure Monitor",
        "D) Autoscale"
      ],
      "multi_select": false,
      "hint": "Snapshot Debugger is correct.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Snapshot Debugger in Application Insights allows capturing snapshots of variables and call stacks when exceptions occur in production. NSG logs capture network traffic, Azure Monitor aggregates metrics, and Autoscale adjusts capacity but none provide code-level snapshots."
    },
    {
      "id": 11,
      "domain": "Integration",
      "question": "Which APIM policy validates JWT tokens?",
      "options": [
        "A) validate-jwt",
        "B) rate-limit",
        "C) set-header",
        "D) cache-lookup"
      ],
      "multi_select": false,
      "hint": "validate-jwt policy.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The validate-jwt policy in API Management verifies that incoming tokens are valid and unaltered. This ensures requests are properly authenticated before being passed to the backend. Other policies like rate-limit or cache-lookup serve different purposes unrelated to token validation."
    },
    {
      "id": 12,
      "domain": "IaaS",
      "question": "Which VM extension runs custom scripts after deploy?",
      "options": [
        "A) DSC",
        "B) Custom Script Extension",
        "C) OMS",
        "D) Diagnostics"
      ],
      "multi_select": false,
      "hint": "Custom Script Extension runs scripts.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Custom Script Extension for VMs allows running post-deployment scripts to configure software or perform initialization. DSC configures desired state over time, OMS is a monitoring extension, and Diagnostics captures logs, not arbitrary script execution."
    },
    {
      "id": 13,
      "domain": "Compute",
      "question": "Which Functions plan bills only for execution time but may suffer cold starts?",
      "options": [
        "A) Premium",
        "B) Dedicated",
        "C) Consumption",
        "D) ASE"
      ],
      "multi_select": false,
      "hint": "Pay-per-execution is key.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The Consumption plan charges only for the actual execution time and resources consumed by Azure Functions. This makes it cost-efficient for bursty workloads, but functions may experience cold starts. Premium and Dedicated eliminate cold starts but come with fixed costs."
    },
    {
      "id": 14,
      "domain": "Storage",
      "question": "Which Cosmos DB concept ensures even distribution of load?",
      "options": [
        "A) Partition key",
        "B) Consistency level",
        "C) RU/s",
        "D) Indexing policy"
      ],
      "multi_select": false,
      "hint": "Think partitions.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Cosmos DB partition keys distribute data and throughput evenly across physical partitions, preventing hot spots. Consistency level defines read guarantees, RU/s is throughput capacity, and indexing policy affects query performance but not partition distribution."
    },
    {
      "id": 15,
      "domain": "Security",
      "question": "Which OAuth flow is recommended for daemon apps?",
      "options": [
        "A) Client Credentials",
        "B) PKCE",
        "C) ROPC",
        "D) Implicit"
      ],
      "multi_select": false,
      "hint": "No user present.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Daemon apps should use the Client Credentials flow because they run without user interaction and authenticate directly with Azure AD using an app identity. PKCE is designed for SPAs, ROPC is insecure and not recommended, and Implicit is deprecated."
    },
    {
      "id": 16,
      "domain": "Monitoring",
      "question": "Which log service uses KQL queries?",
      "options": [
        "A) Log Analytics",
        "B) Metrics Explorer",
        "C) Alerts",
        "D) Monitor Insights"
      ],
      "multi_select": false,
      "hint": "Query language.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Log Analytics is the Azure service that allows querying logs with Kusto Query Language (KQL). Metrics Explorer visualizes numeric metrics only, Alerts notify based on conditions, and Monitor Insights provide overviews but not ad-hoc querying."
    },
    {
      "id": 17,
      "domain": "Integration",
      "question": "Which Azure messaging service supports sessions for ordered delivery?",
      "options": [
        "A) Storage Queue",
        "B) Event Hubs",
        "C) Service Bus",
        "D) Event Grid"
      ],
      "multi_select": false,
      "hint": "Enterprise messaging.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Service Bus supports sessions to enable ordered message delivery across multiple receivers. Storage Queues don’t support sessions, Event Hubs is for telemetry ingestion, and Event Grid is for lightweight event routing."
    },
    {
      "id": 18,
      "domain": "IaaS",
      "question": "Which IaC command previews resource changes without applying?",
      "options": [
        "A) az deployment group what-if",
        "B) az bicep build",
        "C) az resource show",
        "D) az group create"
      ],
      "multi_select": false,
      "hint": "Dry-run for deployments.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'az deployment group what-if' command previews resource changes without applying them, allowing safe dry-run validation of templates. 'az bicep build' transpiles Bicep to ARM JSON, 'az resource show' inspects resources, and 'az group create' creates groups."
    },
    {
      "id": 19,
      "domain": "Compute",
      "question": "Which App Service feature allows traffic splitting for canary releases?",
      "options": [
        "A) Access Restrictions",
        "B) Slots traffic routing",
        "C) Scaling",
        "D) ASE"
      ],
      "multi_select": false,
      "hint": "Percentage-based routing.",
      "correct_answers": [
        "B"
      ],
      "explanation": "App Service Deployment Slots allow routing a percentage of traffic to different slots, enabling safe canary releases. Access Restrictions limit inbound traffic sources, Scaling adjusts capacity, and ASE provides network isolation."
    },
    {
      "id": 20,
      "domain": "Storage",
      "question": "Which blob feature provides immutability for compliance?",
      "options": [
        "A) Archive tier",
        "B) Legal Hold",
        "C) Soft Delete",
        "D) CORS"
      ],
      "multi_select": false,
      "hint": "Write once, read many.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Blob Legal Hold (Immutable Storage) prevents data from being modified or deleted until explicitly released, ensuring compliance. Archive tier reduces costs but doesn’t prevent deletion, Soft Delete allows recovery, and CORS configures access rules."
    },
    {
      "id": 21,
      "domain": "Security",
      "question": "Which two claims should an API validate in JWT tokens?",
      "options": [
        "A) Audience",
        "B) Issuer",
        "C) Tenant ID",
        "D) Resource Group"
      ],
      "multi_select": true,
      "hint": "Who issued it, who it’s for.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "APIs should validate the 'aud' (audience) claim to ensure the token is intended for them and the 'iss' (issuer) claim to confirm it comes from the trusted authority. Tenant ID may appear in claims but is not always required, and resource group is irrelevant."
    },
    {
      "id": 22,
      "domain": "Monitoring",
      "question": "Which feature samples telemetry but keeps all errors?",
      "options": [
        "A) Fixed sampling",
        "B) Adaptive sampling with exception exclusions",
        "C) Disable sampling",
        "D) Live Metrics"
      ],
      "multi_select": false,
      "hint": "Smart sampling.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Adaptive sampling with exception exclusions reduces telemetry volume while ensuring all error events are retained. Fixed sampling may drop errors, disabling sampling is costly, and Live Metrics shows near real-time data but isn’t sampling control."
    },
    {
      "id": 23,
      "domain": "Integration",
      "question": "Which service is best for reactive eventing with multiple subscribers?",
      "options": [
        "A) Event Grid",
        "B) Event Hubs",
        "C) Service Bus",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Lightweight pub/sub.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid provides lightweight pub/sub eventing with multiple subscribers and low latency. Event Hubs ingests telemetry at scale, Service Bus provides enterprise queues, and Queue Storage offers basic messaging."
    },
    {
      "id": 24,
      "domain": "IaaS",
      "question": "Which VM extension configures Linux at first boot?",
      "options": [
        "A) DSC",
        "B) cloud-init",
        "C) OMS",
        "D) Guest Agent"
      ],
      "multi_select": false,
      "hint": "Linux native.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Cloud-init is the native Linux bootstrapping tool that configures settings on first boot, including packages and networking. DSC is for Windows, OMS relates to monitoring, and the Guest Agent provides VM interaction but not full initialization scripting."
    },
    {
      "id": 25,
      "domain": "Compute",
      "question": "Which Functions pattern returns 202 Accepted and a status URL?",
      "options": [
        "A) Fan-out/fan-in",
        "B) Async HTTP API",
        "C) External Events",
        "D) Entity Functions"
      ],
      "multi_select": false,
      "hint": "Polling pattern.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Async HTTP API pattern in Durable Functions returns a 202 Accepted response with a status endpoint, allowing clients to poll for results. Fan-out/fan-in handles parallel tasks, External Events wait for signals, and Entity Functions manage stateful entities."
    },
    {
      "id": 26,
      "domain": "Storage",
      "question": "Which SDK condition prevents overwriting a blob if it exists?",
      "options": [
        "A) Overwrite=true",
        "B) If-None-Match=* ETag",
        "C) SAS token",
        "D) Blob tiering"
      ],
      "multi_select": false,
      "hint": "Conditional upload.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The 'If-None-Match=*' ETag condition in blob uploads ensures the operation only succeeds if the blob does not already exist, preventing accidental overwrites. SAS tokens grant access, tiers set cost/performance, but neither enforce concurrency control."
    },
    {
      "id": 27,
      "domain": "Security",
      "question": "Which OAuth flow is used for devices with limited input like TVs?",
      "options": [
        "A) Auth Code",
        "B) Device Code",
        "C) PKCE",
        "D) Client Credentials"
      ],
      "multi_select": false,
      "hint": "Think Xbox login.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Device Code flow is designed for devices with limited input like TVs or IoT, letting users complete sign-in on another device. Auth Code is for apps with full browsers, PKCE is for SPAs, and Client Credentials is for daemons."
    },
    {
      "id": 28,
      "domain": "Monitoring",
      "question": "Which service lets you write KQL to analyze telemetry?",
      "options": [
        "A) Log Analytics",
        "B) Metrics",
        "C) Alerts",
        "D) App Service Logs"
      ],
      "multi_select": false,
      "hint": "Query at scale.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Log Analytics provides the ability to query telemetry across resources using KQL. Metrics provides numeric counters, Alerts trigger on conditions, and App Service Logs are per-app but lack cross-resource querying."
    },
    {
      "id": 29,
      "domain": "Integration",
      "question": "Which APIM policy enforces request limits per subscription?",
      "options": [
        "A) rate-limit-by-key",
        "B) validate-jwt",
        "C) rewrite-uri",
        "D) retry"
      ],
      "multi_select": false,
      "hint": "Throttling policy.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'rate-limit-by-key' policy in API Management enforces per-subscription request limits. Validate-jwt checks tokens, rewrite-uri transforms requests, and retry replays failed requests."
    },
    {
      "id": 30,
      "domain": "IaaS",
      "question": "Which Bicep feature allows parameterizing environment names?",
      "options": [
        "A) Modules",
        "B) String interpolation",
        "C) Conditions",
        "D) SecureString"
      ],
      "multi_select": false,
      "hint": "param + interpolation.",
      "correct_answers": [
        "B"
      ],
      "explanation": "String interpolation in Bicep allows dynamically constructing resource names or parameters, often using parameters for environment names. Modules provide reuse, Conditions enable conditional deployments, and SecureString is for sensitive parameters."
    },
    {
      "id": 31,
      "domain": "Compute",
      "question": "Which Functions trigger automatically scales based on queue length?",
      "options": [
        "A) Timer",
        "B) Queue Storage trigger",
        "C) Event Grid trigger",
        "D) HTTP trigger"
      ],
      "multi_select": false,
      "hint": "Think storage queue.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Queue Storage trigger in Functions automatically scales the number of function instances based on the queue length. Timer triggers run on schedules, Event Grid triggers react to events, and HTTP triggers respond to requests."
    },
    {
      "id": 32,
      "domain": "Storage",
      "question": "Which Cosmos DB consistency provides strongest guarantees?",
      "options": [
        "A) Eventual",
        "B) Bounded staleness",
        "C) Session",
        "D) Strong"
      ],
      "multi_select": false,
      "hint": "Read-your-writes globally.",
      "correct_answers": [
        "D"
      ],
      "explanation": "Strong consistency in Cosmos DB provides linearizable reads globally, ensuring clients always see the latest committed write. Session is weaker but scoped to a client session, Bounded Staleness provides controlled lag, and Eventual offers minimal guarantees."
    },
    {
      "id": 33,
      "domain": "Security",
      "question": "Which Azure feature lets you inject secrets into App Service config without code?",
      "options": [
        "A) Key Vault reference",
        "B) App Settings",
        "C) Managed Identity only",
        "D) FTP publish"
      ],
      "multi_select": false,
      "hint": "@Microsoft.KeyVault syntax.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Key Vault references in App Service configuration allow secrets to be injected via the @Microsoft.KeyVault syntax without modifying application code. Managed Identity provides authentication, while app settings and FTP deployment don’t secure secrets."
    },
    {
      "id": 34,
      "domain": "Monitoring",
      "question": "Which KQL function groups events by 5-minute bins?",
      "options": [
        "A) extend()",
        "B) project()",
        "C) bin()",
        "D) where()"
      ],
      "multi_select": false,
      "hint": "Aggregation buckets.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The 'bin()' function in KQL groups events into fixed time buckets, such as 5-minute intervals. Extend() creates calculated columns, project() selects fields, and where() filters rows."
    },
    {
      "id": 35,
      "domain": "Integration",
      "question": "Which Azure service routes cloud events to Functions or Logic Apps?",
      "options": [
        "A) Service Bus",
        "B) Event Grid",
        "C) Event Hubs",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Reactive pub/sub.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Event Grid is the service for routing cloud-native events to subscribers like Functions or Logic Apps with low latency. Service Bus is for enterprise messaging, Event Hubs ingests telemetry, and Queue Storage is simpler queuing."
    },
    {
      "id": 36,
      "domain": "IaaS",
      "question": "Which VM extension installs software on Windows after deployment?",
      "options": [
        "A) DSC",
        "B) Custom Script Extension",
        "C) Diagnostics",
        "D) OMS"
      ],
      "multi_select": false,
      "hint": "Post-deploy scripts.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Custom Script Extension for Windows VMs runs scripts post-deployment to install software or perform setup. DSC enforces desired state, Diagnostics collects monitoring data, and OMS is for monitoring integration."
    },
    {
      "id": 37,
      "domain": "Compute",
      "question": "Which Azure container service scales to zero and integrates with KEDA?",
      "options": [
        "A) AKS",
        "B) Container Apps",
        "C) ACI",
        "D) App Service Linux"
      ],
      "multi_select": false,
      "hint": "Serverless containers.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Container Apps support scaling to zero and integrate with KEDA for event-driven scaling. AKS is full Kubernetes, ACI runs single containers without scaling, and App Service Linux is for web apps not microservices."
    },
    {
      "id": 38,
      "domain": "Storage",
      "question": "Which feature allows restoring blobs deleted within last X days?",
      "options": [
        "A) Soft delete",
        "B) Versioning",
        "C) Legal Hold",
        "D) Archive tier"
      ],
      "multi_select": false,
      "hint": "Recycle bin for blobs.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Soft delete in Blob Storage allows restoring blobs deleted within the retention period, acting like a recycle bin. Versioning retains previous versions, Legal Hold locks data, and Archive tier changes storage cost."
    },
    {
      "id": 39,
      "domain": "Security",
      "question": "Which two are valid approaches for API authorization?",
      "options": [
        "A) OAuth scopes",
        "B) App roles",
        "C) Shared secrets in code",
        "D) Disable token validation"
      ],
      "multi_select": true,
      "hint": "Claims-based model.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "OAuth scopes and App Roles are valid approaches for API authorization since they integrate with Azure AD claims. Shared secrets hardcoded in code and disabling validation are insecure and not recommended."
    },
    {
      "id": 40,
      "domain": "Monitoring",
      "question": "Which tool visualizes telemetry across multiple subscriptions?",
      "options": [
        "A) Workbooks",
        "B) Metrics Explorer",
        "C) Traffic Manager",
        "D) Log Analytics"
      ],
      "multi_select": false,
      "hint": "Dashboards + KQL.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Workbooks provide interactive dashboards that can aggregate telemetry across multiple subscriptions using KQL queries. Metrics Explorer is scoped per resource, Traffic Manager is DNS load balancing, and Log Analytics provides raw query capability."
    },
    {
      "id": 41,
      "domain": "Integration",
      "question": "Which messaging service guarantees FIFO within sessions?",
      "options": [
        "A) Event Hubs",
        "B) Service Bus",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Enterprise-grade queues.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Service Bus supports sessions to guarantee FIFO delivery within a session, making it suitable for ordered enterprise workflows. Event Hubs and Event Grid do not guarantee order, and Queue Storage is basic messaging without FIFO sessions."
    },
    {
      "id": 42,
      "domain": "IaaS",
      "question": "Which Bicep parameter type is used for passwords?",
      "options": [
        "A) string",
        "B) secureString",
        "C) object",
        "D) bool"
      ],
      "multi_select": false,
      "hint": "Sensitive input type.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The 'secureString' parameter type in Bicep/ARM ensures sensitive values like passwords are handled securely and not logged. Regular strings are visible in logs, objects hold structured data, and bool is for true/false values."
    },
    {
      "id": 43,
      "domain": "Compute",
      "question": "Which Azure service lets you run lightweight background jobs in App Service?",
      "options": [
        "A) WebJobs",
        "B) Functions",
        "C) Logic Apps",
        "D) Batch"
      ],
      "multi_select": false,
      "hint": "Attach to App Service.",
      "correct_answers": [
        "A"
      ],
      "explanation": "WebJobs allow running background jobs attached to App Service apps, suitable for lightweight tasks. Functions provide serverless execution, Logic Apps handle workflows, and Batch is for large-scale compute jobs."
    },
    {
      "id": 44,
      "domain": "Storage",
      "question": "Which Cosmos DB pricing option auto-adjusts RU/s?",
      "options": [
        "A) Manual throughput",
        "B) Autoscale throughput",
        "C) Serverless",
        "D) Free tier"
      ],
      "multi_select": false,
      "hint": "Elastic scaling.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Cosmos DB autoscale throughput automatically adjusts RU/s between a configured range based on workload demand. Manual throughput is fixed, serverless charges per request, and free tier reduces costs but does not autoscale."
    },
    {
      "id": 45,
      "domain": "Security",
      "question": "Which Key Vault integration avoids code changes in App Service?",
      "options": [
        "A) References in app settings",
        "B) SDK call",
        "C) Hardcoded secret",
        "D) FTP deploy"
      ],
      "multi_select": false,
      "hint": "Config reference.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Key Vault references in App Service settings allow apps to retrieve secrets securely without code changes. SDK calls require explicit programming, hardcoded secrets are insecure, and FTP deployment does not manage secrets."
    },
    {
      "id": 46,
      "domain": "Monitoring",
      "question": "Which feature collects dependency tracking in .NET apps?",
      "options": [
        "A) Application Insights SDK",
        "B) NSG flow logs",
        "C) Log Analytics only",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Code instrumentation.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Application Insights SDK automatically collects dependency tracking in .NET applications, showing calls to SQL, HTTP, or other services. NSG flow logs capture network activity, Log Analytics queries logs, and Alerts only notify conditions."
    },
    {
      "id": 47,
      "domain": "Integration",
      "question": "Which Event Grid handshake is required for webhooks?",
      "options": [
        "A) Return 401",
        "B) Return validationCode",
        "C) Return 200 OK always",
        "D) Send SAS"
      ],
      "multi_select": false,
      "hint": "Subscription validation.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Event Grid webhook subscriptions require the subscriber to echo back the validationCode during handshake to confirm ownership. Returning 200 always or sending SAS is incorrect, and 401 rejects the handshake."
    },
    {
      "id": 48,
      "domain": "IaaS",
      "question": "Which Bicep feature allows reusable resource definitions?",
      "options": [
        "A) Modules",
        "B) Outputs",
        "C) Params",
        "D) Conditions"
      ],
      "multi_select": false,
      "hint": "Reusable code.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Modules in Bicep allow packaging and reusing resource definitions across templates, promoting modular design. Outputs return values, params define input, and conditions enable conditional deployment."
    },
    {
      "id": 49,
      "domain": "Compute",
      "question": "Which Durable Functions pattern fans out to parallel tasks and aggregates results?",
      "options": [
        "A) Chaining",
        "B) Fan-out/fan-in",
        "C) Async HTTP API",
        "D) External Events"
      ],
      "multi_select": false,
      "hint": "Parallel workloads.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The fan-out/fan-in pattern in Durable Functions runs multiple tasks in parallel and then aggregates the results. Chaining runs sequentially, Async HTTP API provides polling, and External Events wait for external signals."
    },
    {
      "id": 50,
      "domain": "Storage",
      "question": "Which Cosmos DB mode charges only per request with no RU provisioning?",
      "options": [
        "A) Autoscale",
        "B) Provisioned throughput",
        "C) Serverless",
        "D) Manual"
      ],
      "multi_select": false,
      "hint": "Pay-per-request.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Cosmos DB Serverless charges only per request without requiring provisioned throughput. Autoscale adjusts provisioned RUs, provisioned throughput reserves RUs, and manual provisioning is static."
    },
    {
      "id": 51,
      "domain": "Security",
      "question": "Which Azure AD object grants permissions to a service principal?",
      "options": [
        "A) Role assignment",
        "B) App role",
        "C) Tenant",
        "D) Subscription"
      ],
      "multi_select": false,
      "hint": "Tied to identity.",
      "correct_answers": [
        "B"
      ],
      "explanation": "App Roles in Azure AD applications grant permissions to service principals and can be assigned to users or groups. Role assignments are for Azure RBAC, tenants and subscriptions define scope but don’t directly grant app-level permissions."
    },
    {
      "id": 52,
      "domain": "Monitoring",
      "question": "Which App Insights feature streams live telemetry in real time?",
      "options": [
        "A) Live Metrics Stream",
        "B) Log Analytics",
        "C) Alerts",
        "D) Workbooks"
      ],
      "multi_select": false,
      "hint": "See live requests.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Live Metrics Stream in Application Insights provides real-time telemetry such as requests, failures, and performance. Log Analytics queries historical logs, Alerts trigger on conditions, and Workbooks provide dashboards."
    },
    {
      "id": 53,
      "domain": "Integration",
      "question": "Which Event Hub concept allows multiple consumers to process data independently?",
      "options": [
        "A) Sessions",
        "B) Consumer groups",
        "C) Partitions",
        "D) Topics"
      ],
      "multi_select": false,
      "hint": "Parallel readers.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Consumer groups in Event Hubs allow multiple independent applications to read the same event stream without interfering with each other. Sessions are for ordered messaging in Service Bus, partitions divide load, and topics are a Service Bus concept."
    },
    {
      "id": 54,
      "domain": "IaaS",
      "question": "Which keyword in Bicep allows referencing an already existing resource?",
      "options": [
        "A) resource",
        "B) existing",
        "C) import",
        "D) output"
      ],
      "multi_select": false,
      "hint": "For existing infra.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The 'existing' keyword in Bicep allows referencing already deployed resources instead of creating new ones. 'Resource' declares new resources, 'import' is not valid in Bicep, and 'output' defines outputs."
    },
    {
      "id": 55,
      "domain": "Compute",
      "question": "Which setting enables App Service apps to run from a read-only zip package?",
      "options": [
        "A) WEBSITE_RUN_FROM_PACKAGE",
        "B) Always On",
        "C) SCM_DO_BUILD_DURING_DEPLOYMENT",
        "D) APPINSIGHTS_INSTRUMENTATIONKEY"
      ],
      "multi_select": false,
      "hint": "App setting flag.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Setting WEBSITE_RUN_FROM_PACKAGE to 1 in App Service enables running apps directly from a read-only zip package. This improves consistency and speeds up deployment. Always On keeps apps warm but doesn’t affect deployment packaging."
    },
    {
      "id": 56,
      "domain": "Storage",
      "question": "Which Cosmos DB feature helps avoid hot partitions?",
      "options": [
        "A) High cardinality partition keys",
        "B) Strong consistency",
        "C) Free tier",
        "D) Secondary indexes"
      ],
      "multi_select": false,
      "hint": "Spread load evenly.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Choosing a high-cardinality partition key in Cosmos DB spreads load evenly, helping avoid hot partitions. Strong consistency affects reads, free tier is cost-related, and secondary indexes improve queries but not partition balance."
    },
    {
      "id": 57,
      "domain": "Security",
      "question": "Which flow is NOT recommended and being deprecated?",
      "options": [
        "A) Implicit",
        "B) Device Code",
        "C) PKCE",
        "D) Client Credentials"
      ],
      "multi_select": false,
      "hint": "Old SPA flow.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Implicit flow is deprecated and no longer recommended because it exposes tokens in URLs. PKCE is the modern replacement for SPAs, Device Code is for devices with limited input, and Client Credentials is for daemons."
    },
    {
      "id": 58,
      "domain": "Monitoring",
      "question": "Which resource setting routes logs to Log Analytics?",
      "options": [
        "A) Diagnostic settings",
        "B) Alerts",
        "C) Metrics explorer",
        "D) Action groups"
      ],
      "multi_select": false,
      "hint": "Per-resource configuration.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Diagnostic settings configure which logs and metrics from a resource are sent to Log Analytics, Event Hub, or Storage. Alerts respond to conditions, Metrics Explorer charts values, and Action Groups define alert responses."
    },
    {
      "id": 59,
      "domain": "Integration",
      "question": "Which APIM policy limits client calls by subscription key?",
      "options": [
        "A) rate-limit-by-key",
        "B) quota-by-key",
        "C) cache-lookup",
        "D) validate-jwt"
      ],
      "multi_select": false,
      "hint": "Quota enforcement.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The quota-by-key policy in API Management enforces usage quotas per subscription key, limiting total calls over a time period. Rate-limit-by-key controls request rate but not quota, cache-lookup affects caching, and validate-jwt checks tokens."
    },
    {
      "id": 60,
      "domain": "IaaS",
      "question": "Which Azure VM bootstrapping tool is used natively on Linux?",
      "options": [
        "A) cloud-init",
        "B) DSC",
        "C) Puppet",
        "D) OMS"
      ],
      "multi_select": false,
      "hint": "Linux initialization.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Cloud-init is the native Linux initialization tool used for bootstrapping VMs with configurations like users and packages. DSC is a Windows configuration tool, Puppet is third-party, and OMS relates to monitoring."
    },
    {
      "id": 61,
      "domain": "Compute",
      "question": "Which Azure service processes tasks on a schedule with no server management?",
      "options": [
        "A) Logic Apps with Recurrence",
        "B) Functions Timer trigger",
        "C) AKS CronJob",
        "D) WebJobs Continuous"
      ],
      "multi_select": false,
      "hint": "Timer-based serverless.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Functions Timer trigger allows you to run scheduled tasks in a serverless way with no infrastructure management. Logic Apps with recurrence also schedule tasks but are more for workflow integration. AKS CronJobs require Kubernetes and server management. WebJobs Continuous run constantly, not on schedules."
    },
    {
      "id": 62,
      "domain": "Storage",
      "question": "Which Cosmos DB consistency is default and balances performance with guarantees?",
      "options": [
        "A) Strong",
        "B) Bounded Staleness",
        "C) Session",
        "D) Eventual"
      ],
      "multi_select": false,
      "hint": "Default choice.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Session consistency is the default in Cosmos DB. It provides read-your-writes and monotonic reads within a client session, balancing performance and guarantees. Strong consistency is slower and costly, Bounded Staleness provides controlled lag, and Eventual is fast but provides weaker guarantees."
    },
    {
      "id": 63,
      "domain": "Security",
      "question": "Which Key Vault access model is recommended for new deployments?",
      "options": [
        "A) Access policies",
        "B) RBAC",
        "C) Firewall only",
        "D) Public access"
      ],
      "multi_select": false,
      "hint": "Align with Azure RBAC.",
      "correct_answers": [
        "B"
      ],
      "explanation": "RBAC is the recommended model for Key Vault access as it aligns with Azure-wide role-based security. Access policies are still supported but considered legacy. Firewalls restrict networking only, and public access is insecure and not recommended."
    },
    {
      "id": 64,
      "domain": "Monitoring",
      "question": "Which tool lets you build custom dashboards with KQL and charts?",
      "options": [
        "A) Workbooks",
        "B) Metrics Explorer",
        "C) Live Metrics",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Interactive dashboard.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Workbooks allow custom dashboards combining KQL queries, visualizations, and metrics across multiple resources. Metrics Explorer is limited to metrics. Live Metrics shows near real-time telemetry. Alerts notify on conditions but do not create dashboards."
    },
    {
      "id": 65,
      "domain": "Integration",
      "question": "Which Logic Apps trigger listens for blob created events?",
      "options": [
        "A) Event Grid trigger",
        "B) Timer trigger",
        "C) HTTP trigger",
        "D) Queue trigger"
      ],
      "multi_select": false,
      "hint": "Event-driven workflow.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Event Grid trigger in Logic Apps responds to blob creation events and other Azure events in near real time. Timer triggers are schedule-based, HTTP triggers start workflows via calls, and Queue triggers react to queued messages instead of events."
    },
    {
      "id": 66,
      "domain": "IaaS",
      "question": "Which Bicep registry feature allows publishing reusable modules?",
      "options": [
        "A) br: reference",
        "B) Blob storage",
        "C) GitHub repo",
        "D) Key Vault"
      ],
      "multi_select": false,
      "hint": "Module reuse.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Bicep registries (br:) allow publishing and referencing reusable modules, supporting modular IaC patterns. Blob storage and GitHub repos can host files but are not integrated registries. Key Vault is for secrets, not code modules."
    },
    {
      "id": 67,
      "domain": "Compute",
      "question": "Which Azure service lets you host containerized microservices with full Kubernetes control?",
      "options": [
        "A) Container Apps",
        "B) AKS",
        "C) ACI",
        "D) Functions"
      ],
      "multi_select": false,
      "hint": "Managed Kubernetes.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Kubernetes Service (AKS) provides full Kubernetes orchestration with autoscaling, upgrades, and networking. Container Apps abstract away Kubernetes, ACI runs single containers, and Functions provide serverless execution, not orchestration."
    },
    {
      "id": 68,
      "domain": "Storage",
      "question": "Which blob access method grants time-limited access without keys?",
      "options": [
        "A) SAS",
        "B) Account keys",
        "C) CORS",
        "D) Public container"
      ],
      "multi_select": false,
      "hint": "Temporary access.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Shared Access Signatures (SAS) grant time-limited access to blob resources without sharing account keys. Account keys provide full access and should be avoided. CORS manages cross-origin rules, and public containers expose data without restriction."
    },
    {
      "id": 69,
      "domain": "Security",
      "question": "Which Azure AD flow is recommended for SPAs instead of implicit?",
      "options": [
        "A) Auth Code with PKCE",
        "B) Client Credentials",
        "C) Device Code",
        "D) ROPC"
      ],
      "multi_select": false,
      "hint": "Modern SPA flow.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Authorization Code with PKCE is the modern recommended OAuth2 flow for SPAs, offering enhanced security. Client Credentials is for daemon apps, Device Code is for limited input devices, and ROPC is insecure and discouraged."
    },
    {
      "id": 70,
      "domain": "Monitoring",
      "question": "Which alert type uses log query conditions?",
      "options": [
        "A) Log alert",
        "B) Metric alert",
        "C) Activity log alert",
        "D) Action group"
      ],
      "multi_select": false,
      "hint": "KQL-based alert.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Log alerts are created from KQL queries in Log Analytics and trigger when conditions are met. Metric alerts evaluate numeric metrics, Activity log alerts capture control-plane events, and Action groups define alert actions but are not alert types."
    },
    {
      "id": 71,
      "domain": "Integration",
      "question": "Which messaging service is best for telemetry ingestion at scale?",
      "options": [
        "A) Event Hubs",
        "B) Service Bus",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "High throughput.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Hubs is optimized for telemetry ingestion at scale, handling millions of events per second. Service Bus is enterprise messaging with ordering and transactions. Event Grid is for event routing. Queue Storage is for basic messaging."
    },
    {
      "id": 72,
      "domain": "IaaS",
      "question": "Which ARM/Bicep parameter type allows structured secrets?",
      "options": [
        "A) secureObject",
        "B) string",
        "C) int",
        "D) array"
      ],
      "multi_select": false,
      "hint": "Complex secret.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The secureObject type in ARM/Bicep allows structured sensitive inputs such as JSON objects with secrets. SecureString protects single values, while int and array handle non-sensitive types."
    },
    {
      "id": 73,
      "domain": "Compute",
      "question": "Which Functions hosting plan provides predictable pricing with reserved instances?",
      "options": [
        "A) Premium",
        "B) Consumption",
        "C) Dedicated",
        "D) ASE"
      ],
      "multi_select": false,
      "hint": "Reserved capacity.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Dedicated Functions plans (App Service plan) provide predictable pricing by reserving dedicated VM instances. Premium and Consumption scale dynamically. ASE is for isolated environments, not predictable reserved pricing."
    },
    {
      "id": 74,
      "domain": "Storage",
      "question": "Which Cosmos DB capability enables global distribution with multiple write regions?",
      "options": [
        "A) Multi-master replication",
        "B) Eventual consistency",
        "C) Change feed",
        "D) Indexing policy"
      ],
      "multi_select": false,
      "hint": "Active-active writes.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Cosmos DB multi-master replication allows active-active writes across regions with conflict resolution. Eventual consistency defines read behavior, Change Feed streams updates, and Indexing policy improves query performance."
    },
    {
      "id": 75,
      "domain": "Security",
      "question": "Which Azure AD token type is used for API access?",
      "options": [
        "A) ID token",
        "B) Access token",
        "C) Refresh token",
        "D) Session cookie"
      ],
      "multi_select": false,
      "hint": "Bearer token.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Access tokens are bearer tokens used to authorize API access. ID tokens authenticate users to client apps, Refresh tokens obtain new access tokens, and cookies are web session artifacts."
    },
    {
      "id": 76,
      "domain": "Monitoring",
      "question": "Which Azure feature lets you capture snapshots of memory state on exceptions?",
      "options": [
        "A) Snapshot Debugger",
        "B) Log Analytics",
        "C) Profiler",
        "D) Action Groups"
      ],
      "multi_select": false,
      "hint": "Code-level debugging.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Snapshot Debugger in Application Insights captures process memory and variables when exceptions occur, helping debug production issues. Log Analytics queries telemetry, Profiler samples performance traces, and Action Groups trigger alert responses."
    },
    {
      "id": 77,
      "domain": "Integration",
      "question": "Which APIM policy enforces JWT validation on inbound requests?",
      "options": [
        "A) validate-jwt",
        "B) quota-by-key",
        "C) set-variable",
        "D) cache-store"
      ],
      "multi_select": false,
      "hint": "Token enforcement.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The validate-jwt policy in API Management enforces token validation on inbound requests, ensuring only valid JWTs pass through. Quota policies manage call limits, set-variable modifies context, and cache-store affects caching."
    },
    {
      "id": 78,
      "domain": "IaaS",
      "question": "Which command previews Bicep deployment changes without applying?",
      "options": [
        "A) az deployment group what-if",
        "B) az resource show",
        "C) az group create",
        "D) az bicep build"
      ],
      "multi_select": false,
      "hint": "Dry-run.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'az deployment group what-if' command previews Bicep or ARM changes before applying them. 'az resource show' inspects resources, 'az group create' creates groups, and 'az bicep build' transpiles code to ARM JSON but doesn’t preview changes."
    },
    {
      "id": 79,
      "domain": "Compute",
      "question": "Which Functions pattern supports event-driven external approval steps?",
      "options": [
        "A) Fan-out/fan-in",
        "B) External events",
        "C) Async HTTP API",
        "D) Chaining"
      ],
      "multi_select": false,
      "hint": "Wait for signals.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Durable Functions external events pattern pauses workflows until an external signal (approval, callback) is received. Fan-out/fan-in runs parallel tasks, Async HTTP API provides polling, and chaining executes sequential steps."
    },
    {
      "id": 80,
      "domain": "Storage",
      "question": "Which Cosmos DB API is used with SQL-like queries?",
      "options": [
        "A) MongoDB API",
        "B) Cassandra API",
        "C) SQL API",
        "D) Gremlin API"
      ],
      "multi_select": false,
      "hint": "Most common API.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The SQL API in Cosmos DB supports SQL-like querying of JSON documents. The MongoDB API supports Mongo syntax, Cassandra API supports wide-column stores, and Gremlin API supports graph workloads."
    },
    {
      "id": 81,
      "domain": "Security",
      "question": "Which Azure feature provides temporary credentials for workloads to access resources?",
      "options": [
        "A) Managed Identity",
        "B) Service Principal with secret",
        "C) App Registration",
        "D) SAS URL"
      ],
      "multi_select": false,
      "hint": "No credentials needed.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Managed Identity provides temporary credentials automatically managed by Azure, enabling secure access to resources without storing secrets. Service principals with secrets require manual rotation, App Registrations are identities, and SAS URLs are for storage access only."
    },
    {
      "id": 82,
      "domain": "Monitoring",
      "question": "Which KQL function calculates 95th percentile latency?",
      "options": [
        "A) percentile()",
        "B) top()",
        "C) avg()",
        "D) summarize()"
      ],
      "multi_select": false,
      "hint": "Percentiles.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The percentile() KQL function calculates percentile metrics such as 95th latency. Top() returns highest values, avg() calculates mean, and summarize() aggregates but requires functions like percentile inside."
    },
    {
      "id": 83,
      "domain": "Integration",
      "question": "Which messaging service guarantees at least once delivery with DLQ support?",
      "options": [
        "A) Event Hubs",
        "B) Queue Storage",
        "C) Service Bus",
        "D) Event Grid"
      ],
      "multi_select": false,
      "hint": "Enterprise messaging.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Service Bus provides enterprise messaging with at-least-once delivery guarantees and Dead Letter Queues for undeliverable messages. Event Hubs is for telemetry, Queue Storage is basic, and Event Grid is for lightweight pub/sub."
    },
    {
      "id": 84,
      "domain": "IaaS",
      "question": "Which Bicep declaration secures sensitive object input?",
      "options": [
        "A) param mySecret secureObject",
        "B) param mySecret string",
        "C) var mySecret",
        "D) param mySecret int"
      ],
      "multi_select": false,
      "hint": "Structured secret.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The secureObject parameter in Bicep secures structured secrets like JSON. Strings are plain, vars are local values, and ints are numeric, none offering secure object handling."
    },
    {
      "id": 85,
      "domain": "Compute",
      "question": "Which hosting option is best for a low-traffic API that should scale to zero?",
      "options": [
        "A) App Service",
        "B) Premium Functions",
        "C) Consumption Functions",
        "D) AKS"
      ],
      "multi_select": false,
      "hint": "Pay-per-execution.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Consumption Functions scale to zero when idle and charge only per execution, making them ideal for low-traffic APIs. Premium Functions provide reserved instances, App Service provides constant hosting, and AKS is container orchestration."
    },
    {
      "id": 86,
      "domain": "Storage",
      "question": "Which Blob feature prevents modification/deletion for compliance?",
      "options": [
        "A) Versioning",
        "B) Legal Hold / Immutable storage",
        "C) Archive tier",
        "D) Soft Delete"
      ],
      "multi_select": false,
      "hint": "WORM policy.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Immutable storage with Legal Hold enforces WORM (write once, read many) compliance, preventing modification or deletion. Versioning saves past copies, Archive reduces costs, and Soft Delete allows recovery but not immutability."
    },
    {
      "id": 87,
      "domain": "Security",
      "question": "Which token is exchanged for new access tokens without re-login?",
      "options": [
        "A) Access token",
        "B) Refresh token",
        "C) ID token",
        "D) Cookie"
      ],
      "multi_select": false,
      "hint": "Longer lived.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Refresh tokens are long-lived and allow requesting new access tokens without user reauthentication. Access tokens authorize APIs, ID tokens authenticate users, and cookies manage sessions."
    },
    {
      "id": 88,
      "domain": "Monitoring",
      "question": "Which alert type triggers on Activity Log operations like Delete VM?",
      "options": [
        "A) Activity log alert",
        "B) Metric alert",
        "C) Log alert",
        "D) Action group"
      ],
      "multi_select": false,
      "hint": "Control-plane changes.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Activity Log alerts trigger on Azure control-plane events such as resource deletion. Metric alerts monitor performance counters, Log alerts query telemetry, and Action Groups define alert responses."
    },
    {
      "id": 89,
      "domain": "Integration",
      "question": "Which service lets you visually build workflows to integrate SaaS and Azure services?",
      "options": [
        "A) Logic Apps",
        "B) Functions",
        "C) API Management",
        "D) Event Grid"
      ],
      "multi_select": false,
      "hint": "Low-code automation.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Logic Apps provide a low-code designer to visually build workflows integrating SaaS and Azure services. Functions are code-first, API Management secures APIs, and Event Grid routes events."
    },
    {
      "id": 90,
      "domain": "IaaS",
      "question": "Which Bicep output exposes a resource property after deployment?",
      "options": [
        "A) output keyword",
        "B) var keyword",
        "C) existing keyword",
        "D) condition keyword"
      ],
      "multi_select": false,
      "hint": "Return value.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The output keyword in Bicep exposes resource values (like connection strings) after deployment. Vars are internal, existing references existing resources, and conditions enable conditional logic."
    },
    {
      "id": 91,
      "domain": "Compute",
      "question": "Which Functions pattern manages state as single entities?",
      "options": [
        "A) Async HTTP API",
        "B) Entity Functions",
        "C) External Events",
        "D) Fan-out/fan-in"
      ],
      "multi_select": false,
      "hint": "Actor-like.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Entity Functions in Durable Functions manage state as single entities, similar to actors. Async HTTP API is for polling, External Events for signals, and Fan-out/fan-in for parallel workloads."
    },
    {
      "id": 92,
      "domain": "Storage",
      "question": "Which Blob concurrency control mechanism prevents multiple writers?",
      "options": [
        "A) Lease",
        "B) SAS",
        "C) Firewall",
        "D) CORS"
      ],
      "multi_select": false,
      "hint": "Lock blob.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Blob leases enforce concurrency control, preventing multiple writers. SAS grants scoped access, firewalls control network, and CORS configures cross-origin requests but do not lock blobs."
    },
    {
      "id": 93,
      "domain": "Security",
      "question": "Which OAuth2 flow allows an API to call another API without user context?",
      "options": [
        "A) Client Credentials",
        "B) PKCE",
        "C) Device Code",
        "D) ROPC"
      ],
      "multi_select": false,
      "hint": "Daemon scenario.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Client Credentials flow allows an API or daemon app to access another API without user interaction, authenticating with its app identity. PKCE is for SPAs, Device Code for limited input devices, and ROPC is insecure."
    },
    {
      "id": 94,
      "domain": "Monitoring",
      "question": "Which Azure service centralizes logs from multiple subscriptions?",
      "options": [
        "A) Log Analytics workspace",
        "B) Storage Account",
        "C) Monitor Metrics",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Central collection.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Log Analytics workspaces centralize log ingestion from multiple subscriptions and resources. Storage Accounts store data but don’t analyze, Monitor Metrics aggregates counters, and Alerts notify conditions."
    },
    {
      "id": 95,
      "domain": "Integration",
      "question": "Which messaging service uses topics with subscriptions for pub/sub?",
      "options": [
        "A) Queue Storage",
        "B) Service Bus",
        "C) Event Hubs",
        "D) Event Grid"
      ],
      "multi_select": false,
      "hint": "Enterprise pub/sub.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Service Bus Topics and Subscriptions implement enterprise pub/sub, letting multiple subscribers receive filtered messages. Queue Storage is point-to-point, Event Hubs ingests telemetry, and Event Grid routes events."
    },
    {
      "id": 96,
      "domain": "IaaS",
      "question": "Which VM extension ensures compliance configs on Windows?",
      "options": [
        "A) DSC extension",
        "B) Custom Script",
        "C) Diagnostics",
        "D) cloud-init"
      ],
      "multi_select": false,
      "hint": "Desired State.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The DSC (Desired State Configuration) extension enforces compliance and configuration on Windows VMs. Custom Script runs arbitrary scripts, Diagnostics collects logs, and cloud-init is Linux bootstrapping."
    },
    {
      "id": 97,
      "domain": "Compute",
      "question": "Which App Service deployment method allows gradual rollout to slots?",
      "options": [
        "A) GitHub Actions",
        "B) Slot swaps with traffic routing",
        "C) FTP publish",
        "D) Kudu exec"
      ],
      "multi_select": false,
      "hint": "Blue/green.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Slot swaps with traffic routing in App Service enable gradual rollout between deployment slots. GitHub Actions automate CI/CD, FTP publish is manual, and Kudu exec is a command-line tool."
    },
    {
      "id": 98,
      "domain": "Storage",
      "question": "Which Cosmos DB feature streams inserts/updates for downstream processing?",
      "options": [
        "A) Change Feed",
        "B) Partition Key",
        "C) Multi-master",
        "D) Indexing"
      ],
      "multi_select": false,
      "hint": "Event-driven DB.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Change Feed in Cosmos DB streams inserts and updates in order for downstream processing. Partition Key distributes data, Multi-master supports multi-region writes, and Indexing speeds up queries but doesn’t stream changes."
    },
    {
      "id": 99,
      "domain": "Security",
      "question": "Which token type proves authentication to the client app (not API)?",
      "options": [
        "A) Access token",
        "B) ID token",
        "C) Refresh token",
        "D) SAML assertion"
      ],
      "multi_select": false,
      "hint": "OpenID Connect.",
      "correct_answers": [
        "B"
      ],
      "explanation": "ID tokens are issued via OpenID Connect to prove user authentication to the client app. Access tokens are for APIs, Refresh tokens get new tokens, and SAML assertions are used in SAML-based auth flows."
    },
    {
      "id": 100,
      "domain": "Monitoring",
      "question": "Which Application Insights feature helps profile performance hotspots?",
      "options": [
        "A) Profiler",
        "B) Snapshot Debugger",
        "C) Metrics Explorer",
        "D) Live Metrics"
      ],
      "multi_select": false,
      "hint": "Performance profiling.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Application Insights Profiler samples running code in production to identify performance bottlenecks such as slow methods, dependencies, or database calls. Snapshot Debugger is for debugging exceptions, Metrics Explorer is for charts, and Live Metrics is for near real-time telemetry."
    },
    {
      "id": 101,
      "domain": "Compute",
      "question": "You need to deploy a containerized microservice for a proof-of-concept that should start quickly, requires no orchestration, and can be deleted after 24 hours. Which service should you use?",
      "options": [
        "A) Azure Kubernetes Service",
        "B) Azure Container Instances",
        "C) Azure Container Apps",
        "D) App Service Linux"
      ],
      "multi_select": false,
      "hint": "Ephemeral, single-container workloads.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Container Instances (ACI) are best for short-lived, single-container workloads with no orchestration. They start quickly, require minimal setup, and are ideal for proof-of-concepts or jobs under 24 hours. AKS and Container Apps add orchestration overhead, and App Service is better for web hosting."
    },
    {
      "id": 102,
      "domain": "Integration",
      "question": "You must implement a caching layer to improve response times for a high-traffic API. Which Azure service is best suited?",
      "options": [
        "A) Azure Cache for Redis",
        "B) Azure Table Storage",
        "C) Azure SQL Database",
        "D) Azure Blob Storage"
      ],
      "multi_select": false,
      "hint": "Think in-memory caching.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Azure Cache for Redis is an in-memory cache that improves API response times by reducing load on back-end systems. Table Storage, SQL Database, and Blob Storage are persistent stores and not designed for low-latency caching."
    },
    {
      "id": 103,
      "domain": "Security",
      "question": "You are registering a new API in Azure AD that must be accessible by multiple organizations. Which type of app registration should you use?",
      "options": [
        "A) Single-tenant",
        "B) Multi-tenant",
        "C) Service principal only",
        "D) Managed identity"
      ],
      "multi_select": false,
      "hint": "Cross-org access requires multi-tenant.",
      "correct_answers": [
        "B"
      ],
      "explanation": "A multi-tenant app registration in Azure AD allows users from any Azure AD tenant to authenticate. Single-tenant apps restrict access, service principals are identities for automation, and managed identities are for Azure-hosted resources only."
    },
    {
      "id": 104,
      "domain": "Compute",
      "question": "Your team needs a zero-downtime deployment for an App Service app. During the rollout, 10% of users should see the new version before full release. Which feature should you use?",
      "options": [
        "A) Autoscale",
        "B) Deployment slots with traffic routing",
        "C) Traffic Manager",
        "D) Always On"
      ],
      "multi_select": false,
      "hint": "Gradual rollout per percentage.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Deployment slots with traffic routing allow gradual rollout by directing a percentage of users to the staging slot before full release. This enables zero-downtime testing. Autoscale adjusts capacity, Traffic Manager is DNS-based routing, and Always On prevents idle timeouts but doesn’t manage deployments."
    },
    {
      "id": 105,
      "domain": "Storage",
      "question": "You must enforce data immutability for regulatory compliance in Azure Blob Storage. Which two features should you enable?",
      "options": [
        "A) Legal Hold",
        "B) Immutable Storage (time-based retention)",
        "C) Soft Delete",
        "D) Blob Index"
      ],
      "multi_select": true,
      "hint": "WORM storage features.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "Blob Storage immutability is achieved with Legal Hold and Time-Based Retention, enforcing WORM compliance. These prevent modification or deletion for a specified time. Soft delete allows recovery but not compliance, and Blob Index is for tagging."
    },
    {
      "id": 106,
      "domain": "Integration",
      "question": "A Logic App must react to a new file uploaded in a storage account. Which trigger is most efficient?",
      "options": [
        "A) Recurrence trigger with polling",
        "B) Event Grid trigger",
        "C) Service Bus trigger",
        "D) HTTP trigger"
      ],
      "multi_select": false,
      "hint": "Reactive, event-based integration.",
      "correct_answers": [
        "B"
      ],
      "explanation": "A Logic App should use an Event Grid trigger to respond efficiently to new blob uploads. Event Grid delivers push-based events with low latency. Polling is inefficient, Service Bus is for messaging, and HTTP triggers require an external call."
    },
    {
      "id": 107,
      "domain": "Monitoring",
      "question": "Which tool allows you to build custom queries and dashboards across multiple subscriptions using KQL?",
      "options": [
        "A) Metrics Explorer",
        "B) Workbooks",
        "C) Live Metrics Stream",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Interactive dashboards.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Workbooks allow custom dashboards and queries across multiple subscriptions using KQL and visualizations. Metrics Explorer is limited to single resources, Live Metrics shows streaming telemetry, and Alerts notify based on conditions."
    },
    {
      "id": 108,
      "domain": "Security",
      "question": "Your app is using Azure Key Vault. Microsoft recommends moving away from access policies to which model?",
      "options": [
        "A) Role-Based Access Control (RBAC)",
        "B) Public endpoint only",
        "C) IP Firewall rules",
        "D) Shared keys"
      ],
      "multi_select": false,
      "hint": "Align with Azure RBAC.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Azure Key Vault now uses Azure RBAC as the recommended model, replacing access policies. RBAC integrates with Azure AD roles and scopes, providing centralized and granular permission management."
    },
    {
      "id": 109,
      "domain": "Integration",
      "question": "Your company wants to publish APIs to partners. Which Azure service provides rate limiting, quotas, and JWT validation?",
      "options": [
        "A) Azure Front Door",
        "B) Azure API Management",
        "C) Application Gateway",
        "D) Azure Functions Proxies"
      ],
      "multi_select": false,
      "hint": "Full API gateway solution.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure API Management is the full API gateway solution providing quotas, JWT validation, caching, and rate limiting. Front Door and Application Gateway are focused on routing and security at the network layer, and Functions Proxies are lightweight proxies only."
    },
    {
      "id": 110,
      "domain": "Compute",
      "question": "Your team is building a microservices application. You need full Kubernetes control including custom networking and ingress. Which service do you choose?",
      "options": [
        "A) Azure Container Instances",
        "B) Azure Container Apps",
        "C) Azure Kubernetes Service (AKS)",
        "D) App Service Linux"
      ],
      "multi_select": false,
      "hint": "Full Kubernetes cluster control.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Azure Kubernetes Service (AKS) provides full control of Kubernetes clusters, with features like custom networking and ingress. Container Apps simplify container hosting, ACI is for single containers, and App Service is optimized for web apps."
    },
    {
      "id": 111,
      "domain": "Storage",
      "question": "Your Cosmos DB app requires global writes across multiple regions. Which feature should you enable?",
      "options": [
        "A) Multi-master replication",
        "B) Change Feed",
        "C) Indexing policy",
        "D) Serverless mode"
      ],
      "multi_select": false,
      "hint": "Active-active writes.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Cosmos DB multi-master replication allows active-active writes across multiple regions, enabling low-latency global applications. Change Feed streams updates, Indexing policies tune queries, and Serverless is for cost optimization."
    },
    {
      "id": 112,
      "domain": "Monitoring",
      "question": "You need to be alerted when CPU usage on an App Service exceeds 80% for 5 minutes. Which alert type should you configure?",
      "options": [
        "A) Metric alert",
        "B) Activity log alert",
        "C) Log query alert",
        "D) Action group"
      ],
      "multi_select": false,
      "hint": "Performance-based alert.",
      "correct_answers": [
        "A"
      ],
      "explanation": "A metric alert monitors performance counters like CPU or memory usage and fires when thresholds are crossed. Activity log alerts capture control-plane actions, log alerts run KQL queries, and action groups define responses but aren’t alerts themselves."
    },
    {
      "id": 113,
      "domain": "Security",
      "question": "Which OAuth2 flow should be used when a background service must authenticate with no user present?",
      "options": [
        "A) Device Code",
        "B) Client Credentials",
        "C) Authorization Code with PKCE",
        "D) Implicit"
      ],
      "multi_select": false,
      "hint": "Daemon service-to-service.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Client Credentials flow is used for daemon apps or background services where no user is present. Device Code is for limited-input devices, Authorization Code + PKCE is for user-facing apps, and Implicit is legacy and insecure."
    },
    {
      "id": 114,
      "domain": "Integration",
      "question": "You must process 1 million telemetry messages per second with low latency. Which service should you use?",
      "options": [
        "A) Event Hubs",
        "B) Event Grid",
        "C) Service Bus",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Streaming ingestion at scale.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Hubs is designed for massive telemetry ingestion (millions of messages per second) with partitioning and low latency. Event Grid is for lightweight notifications, Service Bus is for ordered enterprise messaging, and Storage Queues are basic queues."
    },
    {
      "id": 115,
      "domain": "Compute",
      "question": "You are asked to configure CI/CD for an Azure Functions app. The pipeline must build and deploy automatically on commit. Which tool combination is best?",
      "options": [
        "A) GitHub Actions with Azure Functions Deploy action",
        "B) FTP Publish",
        "C) Manual zip deploy",
        "D) Copy via Storage Explorer"
      ],
      "multi_select": false,
      "hint": "Microsoft exams like DevOps automation.",
      "correct_answers": [
        "A"
      ],
      "explanation": "GitHub Actions with the Azure Functions Deploy action automates CI/CD for Functions. FTP and manual zip deploys are error-prone, and Storage Explorer is for data management, not deployments."
    },
    {
      "id": 116,
      "domain": "Compute",
      "question": "Your company runs a high-traffic API on Azure App Service. During a new deployment, you must avoid downtime and test the new version with 20% of traffic before full rollout. Which solution should you implement?",
      "options": [
        "A) Scale out to multiple instances",
        "B) Deployment slots with traffic routing",
        "C) Use Azure Front Door with health probes",
        "D) Enable Always On"
      ],
      "multi_select": false,
      "hint": "Microsoft loves deployment slot questions.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Deployment slots with traffic routing in App Service enable zero-downtime deployments and traffic splitting (like 20% rollout). Scaling adjusts resources, Front Door manages global traffic, and Always On prevents idle but doesn’t control deployment strategy."
    },
    {
      "id": 117,
      "domain": "Security",
      "question": "You are building a daemon service that must authenticate with Microsoft Graph API on behalf of the application itself. No user is present. Which authentication flow should you use?",
      "options": [
        "A) Authorization Code + PKCE",
        "B) Client Credentials",
        "C) Device Code Flow",
        "D) Implicit Flow"
      ],
      "multi_select": false,
      "hint": "No user interaction allowed.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Client Credentials flow is correct for daemon services calling Microsoft Graph without user interaction. PKCE is for SPAs/mobile, Device Code is for limited-input devices, and Implicit is legacy."
    },
    {
      "id": 118,
      "domain": "Integration",
      "question": "An IoT system sends millions of telemetry events per second. You must process and store them with low latency for real-time analytics. Which service should you choose?",
      "options": [
        "A) Event Grid",
        "B) Service Bus",
        "C) Event Hubs",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "High-throughput event ingestion.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Event Hubs is built for IoT and telemetry ingestion, supporting millions of events per second and low-latency analytics. Event Grid routes events, Service Bus supports ordered enterprise workflows, and Queue Storage is basic."
    },
    {
      "id": 119,
      "domain": "Monitoring",
      "question": "You need to be notified if your Function App throws exceptions. The solution must minimize noise but ensure all exceptions are logged. What should you configure?",
      "options": [
        "A) Adaptive sampling with exception exclusions",
        "B) Activity Log Alerts",
        "C) Metric Alerts",
        "D) Fixed Sampling"
      ],
      "multi_select": false,
      "hint": "Keep all errors even when sampling.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Adaptive sampling in Application Insights reduces telemetry volume while still capturing all exceptions. This minimizes noise but ensures error visibility. Fixed sampling may drop exceptions, Activity Log and Metric Alerts don’t capture exceptions."
    },
    {
      "id": 120,
      "domain": "Storage",
      "question": "Your Cosmos DB app must support global availability with active-active writes in multiple regions. Which feature should you enable?",
      "options": [
        "A) Multi-master replication",
        "B) Session consistency",
        "C) Change Feed",
        "D) Free Tier"
      ],
      "multi_select": false,
      "hint": "Think global write regions.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Cosmos DB multi-master replication supports active-active writes across regions for global availability. Session consistency affects reads, Change Feed streams updates, and Free Tier is a pricing model."
    },
    {
      "id": 121,
      "domain": "Compute",
      "question": "A developer deploys a Function App on the Consumption plan. Users report delays on the first request after inactivity. How can you eliminate this latency without overpaying for reserved cores?",
      "options": [
        "A) Scale out to multiple instances",
        "B) Switch to Premium plan",
        "C) Enable Always On",
        "D) Use Azure Front Door caching"
      ],
      "multi_select": false,
      "hint": "Cold start avoidance.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Switching to the Premium plan eliminates cold starts for Functions by keeping pre-warmed instances. Consumption is billed per execution but suffers cold starts, Always On applies only to App Service Plans, and caching via Front Door doesn’t solve cold starts."
    },
    {
      "id": 122,
      "domain": "Storage",
      "question": "You need to prevent accidental overwrites of blob data. Which mechanism should you use?",
      "options": [
        "A) Soft delete",
        "B) Blob lease",
        "C) Legal hold",
        "D) Immutable storage"
      ],
      "multi_select": false,
      "hint": "Think concurrency control.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Blob leases prevent overwrites by locking a blob for a client. Soft delete recovers deleted data, Legal Hold enforces immutability, and Immutable Storage enforces WORM compliance."
    },
    {
      "id": 123,
      "domain": "Security",
      "question": "An SPA uses Azure AD for authentication. Which flow is recommended for security best practices?",
      "options": [
        "A) Implicit Flow",
        "B) Authorization Code Flow with PKCE",
        "C) Resource Owner Password Credentials",
        "D) Client Credentials Flow"
      ],
      "multi_select": false,
      "hint": "Implicit is deprecated.",
      "correct_answers": [
        "B"
      ],
      "explanation": "SPAs should use Authorization Code Flow with PKCE, which is secure against token interception. Implicit Flow is deprecated, ROPC is insecure, and Client Credentials is for daemons."
    },
    {
      "id": 124,
      "domain": "Monitoring",
      "question": "You want to track dependencies (like SQL queries and HTTP calls) from your .NET app automatically. Which feature should you enable?",
      "options": [
        "A) Log Analytics agent",
        "B) Application Insights SDK",
        "C) Network Watcher",
        "D) Profiler"
      ],
      "multi_select": false,
      "hint": "Automatic instrumentation.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Application Insights SDK automatically tracks dependencies such as SQL queries and HTTP calls. Log Analytics agent captures logs, Network Watcher monitors network, and Profiler samples performance traces."
    },
    {
      "id": 125,
      "domain": "Integration",
      "question": "A business workflow must execute in response to blob uploads. Which service provides the most event-driven and cost-effective solution?",
      "options": [
        "A) Logic App with Event Grid trigger",
        "B) Logic App with polling",
        "C) Service Bus",
        "D) Event Hubs"
      ],
      "multi_select": false,
      "hint": "Avoid polling.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Logic App with Event Grid trigger provides event-driven execution for blob uploads, avoiding polling and reducing costs. Polling is inefficient, Service Bus is messaging, and Event Hubs is for telemetry ingestion."
    },
    {
      "id": 126,
      "domain": "IaaS",
      "question": "You need to configure Linux VMs during provisioning with SSH keys and packages. Which extension should you use?",
      "options": [
        "A) DSC extension",
        "B) cloud-init",
        "C) Custom Script Extension",
        "D) Diagnostics extension"
      ],
      "multi_select": false,
      "hint": "Native Linux bootstrap.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Cloud-init is the native Linux configuration method for provisioning, supporting SSH keys, package installs, and script execution. DSC extension is for Windows, Custom Script runs after provisioning, and Diagnostics captures logs."
    },
    {
      "id": 127,
      "domain": "Compute",
      "question": "A long-running process must be executed in parallel across multiple tasks with results aggregated. Which Durable Functions pattern is best?",
      "options": [
        "A) Fan-out/fan-in",
        "B) Chaining",
        "C) Async HTTP API",
        "D) External Events"
      ],
      "multi_select": false,
      "hint": "Think parallel workloads.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Fan-out/Fan-in Durable Functions pattern runs tasks in parallel and aggregates results. Chaining is sequential, Async HTTP API is for polling, and External Events wait for signals."
    },
    {
      "id": 128,
      "domain": "Storage",
      "question": "Your Cosmos DB workload has uneven RU/s usage due to hot partitions. Which two actions could mitigate this?",
      "options": [
        "A) Change to a high-cardinality partition key",
        "B) Enable autoscale throughput",
        "C) Lower consistency level",
        "D) Disable indexing"
      ],
      "multi_select": true,
      "hint": "Balance partitioning + elastic scale.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "Hot partitions in Cosmos DB can be mitigated by using a high-cardinality partition key and enabling autoscale throughput. Lower consistency or disabling indexing won’t fix uneven partition distribution."
    },
    {
      "id": 129,
      "domain": "Security",
      "question": "An API must authorize client apps from multiple tenants. Which Azure AD concept should you implement?",
      "options": [
        "A) Multi-tenant app registration",
        "B) Managed identity",
        "C) Service principal only",
        "D) Group-based RBAC"
      ],
      "multi_select": false,
      "hint": "Cross-tenant authorization.",
      "correct_answers": [
        "A"
      ],
      "explanation": "A multi-tenant Azure AD app registration allows client apps from multiple tenants to authenticate and call your API. Managed identities are for Azure-hosted services, service principals are tenant-specific, and group-based RBAC controls Azure resources."
    },
    {
      "id": 130,
      "domain": "Monitoring",
      "question": "You want near real-time request telemetry during an incident without redeploying your Function App. Which feature should you use?",
      "options": [
        "A) Snapshot Debugger",
        "B) Profiler",
        "C) Live Metrics Stream",
        "D) Diagnostic settings"
      ],
      "multi_select": false,
      "hint": "Stream data as it happens.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Live Metrics Stream shows near real-time telemetry such as requests, failures, and performance, making it useful during incidents. Snapshot Debugger is for exceptions, Profiler samples performance, and Diagnostic Settings export logs."
    },
    {
      "id": 131,
      "domain": "Integration",
      "question": "You are building an event-driven system where multiple services need to react to new user sign-ups. Which service is best for lightweight pub/sub integration?",
      "options": [
        "A) Event Hubs",
        "B) Service Bus",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Focus on event notifications, not messaging queues.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Event Grid provides lightweight pub/sub for events such as user sign-ups, allowing multiple subscribers. Event Hubs is for telemetry ingestion, Service Bus is for enterprise messaging, and Storage Queues are basic."
    },
    {
      "id": 132,
      "domain": "IaaS",
      "question": "You need to preview the resource changes of a Bicep deployment before applying them. Which CLI command should you run?",
      "options": [
        "A) az deployment group create",
        "B) az deployment group validate",
        "C) az deployment group what-if",
        "D) az bicep build"
      ],
      "multi_select": false,
      "hint": "Dry-run preview command.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The 'az deployment group what-if' command previews changes before applying them, showing adds, deletes, or modifications. Validate checks syntax, bicep build transpiles, and resource show inspects an existing resource."
    },
    {
      "id": 133,
      "domain": "Compute",
      "question": "A background service must process tasks continuously and requires predictable pricing with dedicated cores. Which hosting plan should you choose for Azure Functions?",
      "options": [
        "A) Consumption",
        "B) Premium",
        "C) Dedicated (App Service Plan)",
        "D) ASE v3"
      ],
      "multi_select": false,
      "hint": "Reserved, predictable compute.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The Dedicated (App Service Plan) hosting option provides reserved compute with predictable pricing for Functions. Consumption and Premium are elastic, and ASE is for isolation but costly."
    },
    {
      "id": 134,
      "domain": "Storage",
      "question": "Which Cosmos DB consistency level guarantees read-your-writes within a session but allows staleness across regions?",
      "options": [
        "A) Strong",
        "B) Bounded staleness",
        "C) Session",
        "D) Eventual"
      ],
      "multi_select": false,
      "hint": "Default level.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Cosmos DB Session consistency guarantees read-your-writes within a session and allows replication lag across regions. Strong provides strict consistency, Eventual is weakest, and Bounded Staleness enforces lag constraints."
    },
    {
      "id": 135,
      "domain": "Security",
      "question": "Which two claims in a JWT token must always be validated by an API?",
      "options": [
        "A) exp (expiration)",
        "B) aud (audience)",
        "C) iss (issuer)",
        "D) nbf (not before)"
      ],
      "multi_select": true,
      "hint": "Who issued the token, and who it's for.",
      "correct_answers": [
        "B",
        "C"
      ],
      "explanation": "APIs must validate the issuer (iss) to ensure tokens are from a trusted authority and the audience (aud) to ensure they are intended for the API. Expiration and not-before are secondary claims."
    },
    {
      "id": 136,
      "domain": "Monitoring",
      "question": "You want to visualize application telemetry from multiple subscriptions in a single interactive dashboard. Which feature should you use?",
      "options": [
        "A) Metrics Explorer",
        "B) Workbooks",
        "C) Log Analytics queries",
        "D) Azure Monitor alerts"
      ],
      "multi_select": false,
      "hint": "Custom dashboards.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Workbooks provide customizable dashboards combining KQL queries, metrics, and logs across resources and subscriptions. Metrics Explorer is per-resource, Log Analytics is query-only, and Alerts notify on conditions."
    },
    {
      "id": 137,
      "domain": "Integration",
      "question": "A financial system must ensure messages are processed in order per customer. Which service should you choose?",
      "options": [
        "A) Event Hubs",
        "B) Service Bus with sessions",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "FIFO per session.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Service Bus with sessions ensures ordered processing of related messages (FIFO per session). Event Hubs is for telemetry, Event Grid is pub/sub events, and Storage Queues are basic."
    },
    {
      "id": 138,
      "domain": "IaaS",
      "question": "You need to pass a complex JSON object securely as a parameter to a Bicep template. Which parameter type should you use?",
      "options": [
        "A) string",
        "B) object",
        "C) secureObject",
        "D) array"
      ],
      "multi_select": false,
      "hint": "Secure structured input.",
      "correct_answers": [
        "C"
      ],
      "explanation": "SecureObject in Bicep secures structured inputs like JSON objects containing secrets. String, object, or array types aren’t encrypted."
    },
    {
      "id": 139,
      "domain": "Compute",
      "question": "You want to run scripts alongside an Azure App Service app to clean logs and process files periodically. Which feature is best?",
      "options": [
        "A) WebJobs",
        "B) Functions",
        "C) Logic Apps",
        "D) Batch"
      ],
      "multi_select": false,
      "hint": "Attach jobs directly to App Service.",
      "correct_answers": [
        "A"
      ],
      "explanation": "WebJobs run background or scheduled jobs inside App Service alongside your web app. Functions are standalone serverless, Logic Apps are workflow-based, and Batch is for HPC jobs."
    },
    {
      "id": 140,
      "domain": "Storage",
      "question": "Your Cosmos DB container needs to support multi-region writes with low latency. Which feature must you enable?",
      "options": [
        "A) Strong consistency",
        "B) Multi-master replication",
        "C) Partition key",
        "D) Change Feed"
      ],
      "multi_select": false,
      "hint": "Think active-active.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Cosmos DB multi-master replication enables active-active writes with low latency across multiple regions. Strong consistency governs reads, Partition keys distribute data, and Change Feed streams updates."
    },
    {
      "id": 141,
      "domain": "Security",
      "question": "Your team wants to stop hardcoding secrets in code. Which approach should you use for an App Service to retrieve secrets securely?",
      "options": [
        "A) Store secrets in appsettings.json",
        "B) Use Azure Key Vault references with Managed Identity",
        "C) Environment variables in container image",
        "D) Hardcode into source control"
      ],
      "multi_select": false,
      "hint": "Microsoft wants no secrets in code.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The recommended approach is Key Vault references with Managed Identity, allowing App Service to retrieve secrets without storing them in code or config files. Appsettings.json or hardcoding secrets are insecure."
    },
    {
      "id": 142,
      "domain": "Monitoring",
      "question": "You want to capture memory dumps when an exception occurs in production. Which feature should you enable?",
      "options": [
        "A) Profiler",
        "B) Snapshot Debugger",
        "C) Live Metrics",
        "D) NSG flow logs"
      ],
      "multi_select": false,
      "hint": "Code-level debugging tool.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Snapshot Debugger captures stack traces and variable values when exceptions occur in production, helping debug without redeployments. Profiler is for performance, Live Metrics shows telemetry, and NSG logs track network flow."
    },
    {
      "id": 143,
      "domain": "Integration",
      "question": "You are designing a telemetry ingestion pipeline requiring millions of messages per second with partitioning for parallelism. Which service should you choose?",
      "options": [
        "A) Event Grid",
        "B) Service Bus",
        "C) Event Hubs",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Streaming backbone.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Event Hubs is the right choice for massive, partitioned telemetry ingestion pipelines. Event Grid is for event notifications, Service Bus is for enterprise workflows, and Storage Queues are basic."
    },
    {
      "id": 144,
      "domain": "IaaS",
      "question": "Which Bicep feature allows you to package and reuse infrastructure definitions across projects?",
      "options": [
        "A) Outputs",
        "B) Modules",
        "C) Variables",
        "D) Conditions"
      ],
      "multi_select": false,
      "hint": "Think reusability.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Bicep modules allow reusing infrastructure definitions across projects, improving modularity and maintainability. Outputs return values, variables define constants, and conditions toggle resources."
    },
    {
      "id": 145,
      "domain": "Compute",
      "question": "Which Durable Functions pattern returns a 202 Accepted with a status URL for polling?",
      "options": [
        "A) Fan-out/fan-in",
        "B) Chaining",
        "C) Async HTTP API",
        "D) Entity Functions"
      ],
      "multi_select": false,
      "hint": "Useful for long-running APIs.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The Async HTTP API pattern in Durable Functions provides a 202 Accepted response with a status URL for clients to poll long-running workflows. Fan-out/Fan-in is for parallel work, chaining is sequential, and entity functions model state."
    },
    {
      "id": 146,
      "domain": "Storage",
      "question": "You must prevent data from being deleted or overwritten in Blob Storage for 7 years to meet compliance. Which features should you configure?",
      "options": [
        "A) Soft delete",
        "B) Blob versioning",
        "C) Immutable storage with time-based retention",
        "D) Blob index"
      ],
      "multi_select": true,
      "hint": "Think regulatory retention.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Immutable storage with time-based retention ensures compliance by preventing modifications for a fixed duration. This is the proper mechanism for enforcing 7-year data retention policies."
    },
    {
      "id": 147,
      "domain": "Security",
      "question": "A daemon app needs to call Microsoft Graph API on its own behalf. Which flow should it use?",
      "options": [
        "A) Authorization Code with PKCE",
        "B) Client Credentials",
        "C) Device Code",
        "D) Implicit"
      ],
      "multi_select": false,
      "hint": "No user present.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Client Credentials flow is used by daemon apps to call APIs like Microsoft Graph without user context. PKCE is for SPAs, Device Code is for limited-input devices, and Implicit is legacy."
    },
    {
      "id": 148,
      "domain": "Monitoring",
      "question": "You want to trigger alerts when a VM is deleted. Which alert type should you use?",
      "options": [
        "A) Activity log alert",
        "B) Metric alert",
        "C) Log Analytics query alert",
        "D) Action group"
      ],
      "multi_select": false,
      "hint": "Focus on control-plane actions.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Activity Log Alerts notify on control-plane operations such as resource deletions or updates. Metric alerts are performance-based, Log alerts use queries, and Action Groups define responses."
    },
    {
      "id": 149,
      "domain": "Integration",
      "question": "Which APIM policy is used to enforce rate limiting per subscription key?",
      "options": [
        "A) validate-jwt",
        "B) quota-by-key",
        "C) set-header",
        "D) cache-lookup"
      ],
      "multi_select": false,
      "hint": "Quota enforcement.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The quota-by-key policy in API Management enforces quotas and rate limits per subscription key. Validate-jwt enforces token validity, set-header changes headers, and cache policies affect response caching."
    },
    {
      "id": 150,
      "domain": "IaaS",
      "question": "Which Linux-native configuration method is used at provisioning to bootstrap VMs?",
      "options": [
        "A) Custom Script Extension",
        "B) cloud-init",
        "C) DSC extension",
        "D) Azure Automation State Configuration"
      ],
      "multi_select": false,
      "hint": "Standard Linux initialization.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Cloud-init is the standard Linux-native initialization method, used at provisioning for tasks like setting SSH keys, installing packages, or configuring services. Custom Script runs post-provisioning."
    },
    {
      "id": 151,
      "domain": "Compute",
      "question": "Which Azure service lets you run small background jobs inside an App Service app?",
      "options": [
        "A) Logic Apps",
        "B) Azure Batch",
        "C) WebJobs",
        "D) Functions"
      ],
      "multi_select": false,
      "hint": "Attach jobs to App Service.",
      "correct_answers": [
        "C"
      ],
      "explanation": "WebJobs allow background jobs to run alongside an App Service app, triggered by timers, queues, or continuously. Functions provide standalone serverless execution, Batch is for HPC, and Logic Apps for workflows."
    },
    {
      "id": 152,
      "domain": "Storage",
      "question": "Your Cosmos DB app experiences rate-limiting (429 errors). How should you handle this?",
      "options": [
        "A) Retry with exponential backoff",
        "B) Switch to strong consistency",
        "C) Disable partitioning",
        "D) Increase indexing"
      ],
      "multi_select": false,
      "hint": "Respect RU/s limits.",
      "correct_answers": [
        "A"
      ],
      "explanation": "When Cosmos DB returns 429 errors, the recommended practice is to retry with exponential backoff. This respects RU/s limits until throughput is available. Consistency changes or disabling partitioning won’t solve throttling."
    },
    {
      "id": 153,
      "domain": "Security",
      "question": "Which Azure AD flow should SPAs use for secure sign-in?",
      "options": [
        "A) Implicit",
        "B) Authorization Code with PKCE",
        "C) Client Credentials",
        "D) ROPC"
      ],
      "multi_select": false,
      "hint": "Modern SPA approach.",
      "correct_answers": [
        "B"
      ],
      "explanation": "SPAs should use Authorization Code Flow with PKCE. Implicit is insecure, Client Credentials is for daemons, and ROPC bypasses modern security features."
    },
    {
      "id": 154,
      "domain": "Monitoring",
      "question": "Which feature allows you to run real-time KQL queries against telemetry as it streams?",
      "options": [
        "A) Live Metrics Stream",
        "B) Profiler",
        "C) Diagnostic settings",
        "D) Activity log"
      ],
      "multi_select": false,
      "hint": "Streamed data.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Live Metrics Stream enables real-time queries against telemetry as it streams, helping during incidents. Profiler samples performance, Diagnostic settings export logs, and Activity Log tracks control-plane events."
    },
    {
      "id": 155,
      "domain": "Integration",
      "question": "Which messaging service provides dead-letter queues (DLQs) for failed message processing?",
      "options": [
        "A) Event Grid",
        "B) Event Hubs",
        "C) Service Bus",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Enterprise queueing.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Service Bus supports dead-letter queues (DLQs) for failed messages, ensuring they can be inspected and retried. Event Grid and Event Hubs don’t support DLQs, and Queue Storage is basic."
    },
    {
      "id": 156,
      "domain": "IaaS",
      "question": "You want to reference an existing storage account in a Bicep template. Which keyword should you use?",
      "options": [
        "A) existing",
        "B) resource",
        "C) import",
        "D) output"
      ],
      "multi_select": false,
      "hint": "For existing infra.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'existing' keyword in Bicep allows referencing already-deployed resources in a new template. Resource defines new resources, output returns values, and import is not valid in Bicep."
    },
    {
      "id": 157,
      "domain": "Compute",
      "question": "Which Functions plan is billed per execution and can scale to zero?",
      "options": [
        "A) Consumption",
        "B) Premium",
        "C) Dedicated",
        "D) ASE"
      ],
      "multi_select": false,
      "hint": "Pay only when running.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Consumption plan bills Functions per execution and allows them to scale to zero when idle. Premium and Dedicated plans reserve capacity, and ASE provides isolation at higher cost."
    },
    {
      "id": 158,
      "domain": "Storage",
      "question": "Which Cosmos DB API is used to run SQL-like queries?",
      "options": [
        "A) MongoDB API",
        "B) Cassandra API",
        "C) SQL API",
        "D) Gremlin API"
      ],
      "multi_select": false,
      "hint": "Most common API.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The SQL API in Cosmos DB supports SQL-like queries against JSON documents, making it the most commonly used API. MongoDB and Cassandra APIs emulate other databases, and Gremlin is for graph data."
    },
    {
      "id": 159,
      "domain": "Security",
      "question": "Which token type allows an application to obtain new access tokens without re-authenticating the user?",
      "options": [
        "A) Access token",
        "B) Refresh token",
        "C) ID token",
        "D) Session token"
      ],
      "multi_select": false,
      "hint": "Long-lived token.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Refresh tokens allow obtaining new access tokens without reauthenticating the user. Access tokens authorize APIs, ID tokens prove authentication, and session tokens are app-level constructs."
    },
    {
      "id": 160,
      "domain": "Monitoring",
      "question": "Which alert type uses log queries to determine when to trigger?",
      "options": [
        "A) Metric alert",
        "B) Log alert",
        "C) Activity log alert",
        "D) Action group"
      ],
      "multi_select": false,
      "hint": "KQL-driven alert.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Log alerts in Azure Monitor use KQL queries to analyze log data and fire alerts when conditions are met. Metric alerts monitor counters, Activity Log alerts cover control-plane operations, and Action Groups define responses."
    },
    {
      "id": 161,
      "domain": "Integration",
      "question": "Which APIM policy validates JSON Web Tokens (JWTs) in inbound requests?",
      "options": [
        "A) validate-jwt",
        "B) quota-by-key",
        "C) rate-limit",
        "D) set-header"
      ],
      "multi_select": false,
      "hint": "Security policy.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The validate-jwt policy in API Management ensures incoming requests include valid JWT tokens. It validates the signature, issuer, audience, and expiration. Quota-by-key and rate-limit enforce usage policies, while set-header only manipulates headers."
    },
    {
      "id": 162,
      "domain": "IaaS",
      "question": "Which VM extension enforces Windows configuration compliance?",
      "options": [
        "A) DSC extension",
        "B) Custom Script Extension",
        "C) cloud-init",
        "D) OMS agent"
      ],
      "multi_select": false,
      "hint": "Desired State.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Desired State Configuration (DSC) extension enforces Windows configuration compliance on VMs. Custom Script Extension runs scripts, cloud-init is for Linux, and the OMS agent is for monitoring, not configuration."
    },
    {
      "id": 163,
      "domain": "Compute",
      "question": "Which Azure service should you use for fully managed Kubernetes clusters?",
      "options": [
        "A) Azure Container Apps",
        "B) Azure Kubernetes Service (AKS)",
        "C) Azure Container Instances",
        "D) App Service Linux"
      ],
      "multi_select": false,
      "hint": "Full K8s control.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Kubernetes Service (AKS) provides fully managed Kubernetes clusters for container orchestration. Container Apps abstract Kubernetes, Container Instances run single containers, and App Service Linux is for web hosting."
    },
    {
      "id": 164,
      "domain": "Storage",
      "question": "Which Blob feature allows restoring deleted blobs within a retention period?",
      "options": [
        "A) Soft delete",
        "B) Versioning",
        "C) Archive tier",
        "D) Immutable storage"
      ],
      "multi_select": false,
      "hint": "Recycle bin.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Soft delete in Blob Storage retains deleted blobs for a retention period, allowing recovery. Versioning saves previous versions of blobs, Archive reduces storage cost, and Immutable Storage enforces WORM compliance."
    },
    {
      "id": 165,
      "domain": "Security",
      "question": "Which Azure AD token type is intended for APIs to validate authorization?",
      "options": [
        "A) ID token",
        "B) Access token",
        "C) Refresh token",
        "D) Session cookie"
      ],
      "multi_select": false,
      "hint": "Bearer token.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Access tokens are bearer tokens used by clients to access APIs. ID tokens prove authentication to clients, Refresh tokens request new tokens, and cookies manage sessions in web apps."
    },
    {
      "id": 166,
      "domain": "Monitoring",
      "question": "Which Application Insights feature helps profile performance bottlenecks in production?",
      "options": [
        "A) Profiler",
        "B) Snapshot Debugger",
        "C) Live Metrics",
        "D) Workbooks"
      ],
      "multi_select": false,
      "hint": "Think performance.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Application Insights Profiler collects performance traces from production apps to find performance bottlenecks. Snapshot Debugger is for exceptions, Live Metrics shows streaming telemetry, and Workbooks visualize telemetry."
    },
    {
      "id": 167,
      "domain": "Integration",
      "question": "Which service should you use to visually design workflows that integrate SaaS and Azure services?",
      "options": [
        "A) Azure Functions",
        "B) Logic Apps",
        "C) Event Grid",
        "D) API Management"
      ],
      "multi_select": false,
      "hint": "Low-code integration.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Logic Apps is the low-code workflow service for integrating SaaS and Azure services with visual design. Functions are code-based, Event Grid routes events, and API Management secures and manages APIs."
    },
    {
      "id": 168,
      "domain": "IaaS",
      "question": "Which Bicep keyword allows you to expose a resource property after deployment?",
      "options": [
        "A) param",
        "B) output",
        "C) var",
        "D) resource"
      ],
      "multi_select": false,
      "hint": "Return a value.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The output keyword in Bicep allows exposing values, such as connection strings or resource IDs, after deployment. Param declares inputs, var defines constants, and resource declares resources."
    },
    {
      "id": 169,
      "domain": "Compute",
      "question": "Which Durable Functions pattern models stateful entities similar to actors?",
      "options": [
        "A) Async HTTP API",
        "B) Fan-out/fan-in",
        "C) Entity Functions",
        "D) Chaining"
      ],
      "multi_select": false,
      "hint": "Actor model.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Entity Functions in Durable Functions represent stateful entities, following the actor model. Async HTTP API handles long-running APIs, Fan-out/Fan-in runs parallel work, and Chaining executes sequential workflows."
    },
    {
      "id": 170,
      "domain": "Storage",
      "question": "Which concurrency mechanism ensures only one writer can modify a blob at a time?",
      "options": [
        "A) Blob lease",
        "B) Immutable storage",
        "C) SAS token",
        "D) Soft delete"
      ],
      "multi_select": false,
      "hint": "Locking mechanism.",
      "correct_answers": [
        "A"
      ],
      "explanation": "A blob lease ensures only one writer can modify a blob at a time, enforcing concurrency control. Immutable Storage locks data permanently, SAS tokens grant access, and Soft Delete provides recovery."
    },
    {
      "id": 171,
      "domain": "Compute",
      "question": "You need to run a containerized background job for 48 hours without managing servers. Which service should you choose?",
      "options": [
        "A) Azure Kubernetes Service",
        "B) Azure Container Instances",
        "C) Azure Container Apps",
        "D) App Service"
      ],
      "multi_select": false,
      "hint": "Think ephemeral container workloads.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Container Instances (ACI) are the best fit for running containerized background jobs without cluster management. AKS and Container Apps add orchestration overhead, and App Service is tailored for web apps."
    },
    {
      "id": 172,
      "domain": "Storage",
      "question": "A Cosmos DB workload requires low-latency reads in multiple regions but must guarantee read-your-writes consistency within each user session. Which consistency level should you configure?",
      "options": [
        "A) Strong",
        "B) Bounded Staleness",
        "C) Session",
        "D) Eventual"
      ],
      "multi_select": false,
      "hint": "Default and balances performance with guarantees.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Session consistency in Cosmos DB ensures read-your-writes within a session, making it the default and best balance of performance and guarantees. Strong consistency enforces strict ordering but adds latency, while Bounded Staleness and Eventual relax guarantees."
    },
    {
      "id": 173,
      "domain": "Security",
      "question": "Your App Service must authenticate users with Azure AD B2C. Which flow is recommended for mobile apps?",
      "options": [
        "A) Authorization Code with PKCE",
        "B) Implicit Flow",
        "C) Client Credentials",
        "D) Resource Owner Password Credentials (ROPC)"
      ],
      "multi_select": false,
      "hint": "Mobile apps should use secure PKCE.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Authorization Code Flow with PKCE is the recommended OAuth2 flow for mobile apps, protecting against token interception. Implicit Flow is insecure, Client Credentials is app-only, and ROPC is legacy and risky."
    },
    {
      "id": 174,
      "domain": "Monitoring",
      "question": "You need to visualize request latency across multiple regions in real time during an outage. Which feature should you use?",
      "options": [
        "A) Profiler",
        "B) Snapshot Debugger",
        "C) Live Metrics Stream",
        "D) Workbooks"
      ],
      "multi_select": false,
      "hint": "Focus on near real-time telemetry.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Live Metrics Stream provides near real-time telemetry such as request latency and failures, useful during outages. Profiler samples performance, Snapshot Debugger helps debug exceptions, and Workbooks visualize telemetry."
    },
    {
      "id": 175,
      "domain": "Integration",
      "question": "A system must send events to multiple downstream subscribers with minimal overhead. Which service is best?",
      "options": [
        "A) Service Bus",
        "B) Event Grid",
        "C) Event Hubs",
        "D) Storage Queues"
      ],
      "multi_select": false,
      "hint": "Lightweight pub/sub for reactive events.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Event Grid delivers lightweight events to multiple subscribers with minimal overhead, making it ideal for reactive, event-driven integration. Service Bus is for enterprise workflows, Event Hubs is for telemetry ingestion, and Storage Queues are basic."
    },
    {
      "id": 176,
      "domain": "IaaS",
      "question": "You need to preview the impact of an ARM/Bicep deployment before applying it. Which command should you use?",
      "options": [
        "A) az deployment group validate",
        "B) az deployment group what-if",
        "C) az bicep build",
        "D) az resource show"
      ],
      "multi_select": false,
      "hint": "Dry-run analysis of changes.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The 'az deployment group what-if' command previews changes to resources before deployment. Validate checks syntax, bicep build transpiles to ARM JSON, and resource show retrieves properties of an existing resource."
    },
    {
      "id": 177,
      "domain": "Compute",
      "question": "You must run scheduled jobs in an App Service environment without using Azure Functions. Which option should you configure?",
      "options": [
        "A) Timer Trigger Functions",
        "B) WebJobs",
        "C) Azure Batch",
        "D) Logic Apps"
      ],
      "multi_select": false,
      "hint": "Attach jobs directly to App Service.",
      "correct_answers": [
        "B"
      ],
      "explanation": "WebJobs allow scheduled or continuous jobs to run within App Service apps, suitable for background tasks. Functions are separate serverless apps, Batch handles HPC workloads, and Logic Apps orchestrate SaaS integrations."
    },
    {
      "id": 178,
      "domain": "Storage",
      "question": "You must provide auditors with proof that blob data has not been modified or deleted for 7 years. Which two features should you configure?",
      "options": [
        "A) Soft delete",
        "B) Versioning",
        "C) Immutable Storage with time-based retention",
        "D) Legal Hold"
      ],
      "multi_select": true,
      "hint": "WORM compliance features.",
      "correct_answers": [
        "C",
        "D"
      ],
      "explanation": "Immutable Storage with time-based retention and Legal Hold enforce WORM compliance for Blob Storage, ensuring data cannot be deleted or modified. Soft delete and Versioning protect against accidental changes but do not guarantee compliance."
    },
    {
      "id": 179,
      "domain": "Security",
      "question": "Your API must validate tokens from multiple Azure AD tenants. Which concept should you configure?",
      "options": [
        "A) Multi-tenant app registration",
        "B) Managed identity",
        "C) App roles only",
        "D) Service principal only"
      ],
      "multi_select": false,
      "hint": "Cross-tenant access.",
      "correct_answers": [
        "A"
      ],
      "explanation": "A multi-tenant app registration allows an API to validate tokens from users in multiple Azure AD tenants. Managed identities are for Azure resources, app roles define in-app authorization, and service principals are tenant-specific."
    },
    {
      "id": 180,
      "domain": "Monitoring",
      "question": "You want to automatically capture performance traces when request latency exceeds 2 seconds. Which feature should you use?",
      "options": [
        "A) Snapshot Debugger",
        "B) Application Insights Profiler",
        "C) Log Analytics queries",
        "D) Workbooks"
      ],
      "multi_select": false,
      "hint": "Focus on performance profiling.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Application Insights Profiler automatically collects performance traces when request latency exceeds thresholds, identifying performance issues. Snapshot Debugger is for debugging exceptions, Log Analytics queries telemetry, and Workbooks visualize data."
    },
    {
      "id": 181,
      "domain": "Integration",
      "question": "You are designing a workflow where an order system must trigger a payment service and a notification service simultaneously. Which service is best?",
      "options": [
        "A) Service Bus",
        "B) Event Hubs",
        "C) Event Grid",
        "D) Storage Queue"
      ],
      "multi_select": false,
      "hint": "Multiple subscribers for the same event.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Event Grid is ideal for fan-out scenarios where multiple subscribers need to react to the same event, such as triggering payment and notification services simultaneously. Service Bus provides queues, Event Hubs ingests telemetry, and Storage Queues are basic."
    },
    {
      "id": 182,
      "domain": "IaaS",
      "question": "Which Bicep feature allows packaging reusable infrastructure components into a registry?",
      "options": [
        "A) Outputs",
        "B) Modules",
        "C) Registries with br: reference",
        "D) Variables"
      ],
      "multi_select": false,
      "hint": "Think module reuse across projects.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Bicep registries with br: references let you publish and reuse modules across projects. Modules enable reuse locally, Outputs expose values, and Variables define constants but aren’t reusable across projects."
    },
    {
      "id": 183,
      "domain": "Compute",
      "question": "A long-running workflow must wait for external approval events. Which Durable Functions pattern should you use?",
      "options": [
        "A) Fan-out/fan-in",
        "B) Async HTTP API",
        "C) External Events",
        "D) Chaining"
      ],
      "multi_select": false,
      "hint": "Wait for signals from outside systems.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The External Events pattern in Durable Functions pauses workflows until a signal, such as an approval, is received from outside the system. Fan-out/Fan-in runs parallel tasks, Async HTTP API handles polling, and Chaining executes sequential steps."
    },
    {
      "id": 184,
      "domain": "Storage",
      "question": "Which feature ensures that blob writes fail if the blob already exists?",
      "options": [
        "A) If-None-Match condition",
        "B) SAS token",
        "C) Immutable storage",
        "D) Legal hold"
      ],
      "multi_select": false,
      "hint": "Conditional access using ETags.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Using the If-None-Match condition with an ETag ensures writes fail if the blob already exists, preventing overwrites. SAS tokens grant access, Immutable Storage enforces retention, and Legal Hold prevents deletion."
    },
    {
      "id": 185,
      "domain": "Security",
      "question": "Which two claims must always be validated by APIs when processing JWT access tokens?",
      "options": [
        "A) exp (expiration)",
        "B) aud (audience)",
        "C) iss (issuer)",
        "D) nbf (not before)"
      ],
      "multi_select": true,
      "hint": "Who issued the token, and who it’s for.",
      "correct_answers": [
        "B",
        "C"
      ],
      "explanation": "APIs should validate the 'iss' (issuer) to confirm the token comes from a trusted authority and 'aud' (audience) to ensure it is intended for the API. Expiration and not-before are also important but secondary to iss and aud."
    },
    {
      "id": 186,
      "domain": "Monitoring",
      "question": "Which feature allows you to centralize logs from multiple Azure subscriptions?",
      "options": [
        "A) Log Analytics workspace",
        "B) Metrics Explorer",
        "C) Workbooks",
        "D) Diagnostic settings"
      ],
      "multi_select": false,
      "hint": "Central collection and query.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Log Analytics workspaces centralize logs from multiple subscriptions and resources, enabling cross-resource queries. Metrics Explorer provides charts, Workbooks visualize, and Diagnostic Settings export logs but don’t centralize them."
    },
    {
      "id": 187,
      "domain": "Integration",
      "question": "Which APIM policy is used to throttle incoming requests per key?",
      "options": [
        "A) validate-jwt",
        "B) quota-by-key",
        "C) rate-limit-by-key",
        "D) set-header"
      ],
      "multi_select": false,
      "hint": "Focus on request throttling.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The rate-limit-by-key policy in API Management enforces throttling on incoming requests per subscription key. Quota-by-key enforces usage over a time window, validate-jwt validates tokens, and set-header modifies headers."
    },
    {
      "id": 188,
      "domain": "IaaS",
      "question": "You must securely pass a JSON object containing credentials to a Bicep template. Which parameter type should you use?",
      "options": [
        "A) string",
        "B) object",
        "C) secureObject",
        "D) array"
      ],
      "multi_select": false,
      "hint": "Secure structured input.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The secureObject parameter type in Bicep is used to pass sensitive JSON objects, such as credentials, securely. Plain object or string types don’t protect values, and arrays are for collections."
    },
    {
      "id": 189,
      "domain": "Compute",
      "question": "Which Functions hosting plan eliminates cold starts while still auto-scaling?",
      "options": [
        "A) Consumption",
        "B) Premium",
        "C) Dedicated",
        "D) ASE"
      ],
      "multi_select": false,
      "hint": "Think pre-warmed instances.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Premium Functions plan eliminates cold starts by keeping pre-warmed instances, while still scaling elastically. Consumption can scale to zero but suffers cold starts, Dedicated uses fixed VMs, and ASE is isolated and costly."
    },
    {
      "id": 190,
      "domain": "Storage",
      "question": "You need to allow temporary blob access for a client without exposing storage account keys. Which feature should you use?",
      "options": [
        "A) SAS tokens",
        "B) Shared keys",
        "C) CORS",
        "D) Legal hold"
      ],
      "multi_select": false,
      "hint": "Time-limited access.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Shared Access Signatures (SAS) provide temporary, scoped access to Blob Storage without exposing account keys. Shared keys provide full access, CORS controls cross-origin rules, and Legal Hold enforces immutability."
    },
    {
      "id": 191,
      "domain": "Compute",
      "question": "You need to deploy a containerized API that must scale based on HTTP request volume, requires zero downtime updates, and integrates with Dapr sidecars. Which service should you choose?",
      "options": [
        "A) Azure Kubernetes Service",
        "B) Azure Container Instances",
        "C) Azure Container Apps",
        "D) App Service"
      ],
      "multi_select": false,
      "hint": "Think serverless containers with Dapr integration.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Azure Container Apps support HTTP scaling, zero-downtime deployments, and Dapr sidecar integration for microservices, making them ideal for this scenario. AKS is heavier, ACI is for standalone containers, and App Service is for web apps."
    },
    {
      "id": 192,
      "domain": "Storage",
      "question": "Your Cosmos DB application experiences throttling (429 errors). Which two best practices should you implement?",
      "options": [
        "A) Retry with exponential backoff",
        "B) Increase request units (RU/s)",
        "C) Use Event Grid to queue requests",
        "D) Lower the partition key cardinality"
      ],
      "multi_select": true,
      "hint": "Respect RU/s limits and scale appropriately.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "When Cosmos DB returns 429 errors, the best practices are to implement retries with exponential backoff and increase RU/s or enable autoscale. Event Grid isn’t for database throttling, and lowering partition cardinality worsens hotspots."
    },
    {
      "id": 193,
      "domain": "Security",
      "question": "Your SPA must call an API hosted in App Service. Which two practices ensure secure access?",
      "options": [
        "A) Use Authorization Code Flow with PKCE",
        "B) Store client secrets in local storage",
        "C) Enable CORS for trusted origins only",
        "D) Use implicit flow"
      ],
      "multi_select": true,
      "hint": "Avoid implicit flow and insecure secret storage.",
      "correct_answers": [
        "A",
        "C"
      ],
      "explanation": "SPAs should use Authorization Code Flow with PKCE and configure CORS for trusted origins only. Storing secrets in local storage is insecure, and Implicit Flow is deprecated."
    },
    {
      "id": 194,
      "domain": "Monitoring",
      "question": "You need to capture telemetry for a .NET application including SQL dependency calls. Which solution should you use?",
      "options": [
        "A) Azure Monitor Metrics only",
        "B) Application Insights SDK",
        "C) NSG flow logs",
        "D) Log Analytics agent only"
      ],
      "multi_select": false,
      "hint": "Focus on automatic instrumentation.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Application Insights SDK provides automatic instrumentation for .NET applications, capturing requests, dependencies (like SQL), exceptions, and performance metrics. NSG flow logs capture network traffic only."
    },
    {
      "id": 195,
      "domain": "Integration",
      "question": "You need to implement guaranteed message delivery with dead-letter queues (DLQs) and ordered processing. Which service is best?",
      "options": [
        "A) Event Grid",
        "B) Service Bus",
        "C) Event Hubs",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Enterprise queueing with FIFO and DLQs.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Service Bus supports ordered message delivery, transactions, and dead-letter queues, making it the right choice for guaranteed delivery. Event Grid routes events, Event Hubs ingests telemetry, and Storage Queues are basic."
    },
    {
      "id": 196,
      "domain": "IaaS",
      "question": "You want to reuse infrastructure definitions across multiple projects with Bicep. Which two features should you use?",
      "options": [
        "A) Modules",
        "B) Outputs",
        "C) Bicep Registry (br: references)",
        "D) Variables"
      ],
      "multi_select": true,
      "hint": "Think modularity and reusability.",
      "correct_answers": [
        "A",
        "C"
      ],
      "explanation": "Bicep modules and registries (br: references) allow reusing infrastructure definitions across projects. Outputs share values within a template, and variables/parameters are local to a deployment."
    },
    {
      "id": 197,
      "domain": "Compute",
      "question": "You are implementing a Durable Function workflow to run steps sequentially. Which pattern should you use?",
      "options": [
        "A) Fan-out/fan-in",
        "B) Chaining",
        "C) External Events",
        "D) Async HTTP API"
      ],
      "multi_select": false,
      "hint": "Think sequential steps.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Chaining pattern in Durable Functions executes functions sequentially, passing the output of one as input to the next. Fan-out/Fan-in is parallel, External Events wait for signals, and Async HTTP API enables polling."
    },
    {
      "id": 198,
      "domain": "Storage",
      "question": "You need to provide read-only time-limited access to a blob file. Which option should you configure?",
      "options": [
        "A) Immutable Storage",
        "B) Shared Access Signature (SAS)",
        "C) Public container access",
        "D) Managed Identity"
      ],
      "multi_select": false,
      "hint": "Temporary scoped access without keys.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Shared Access Signatures (SAS) provide read-only, time-limited access to blob files. Immutable Storage locks data, public access exposes everything, and Managed Identity is for service authentication."
    },
    {
      "id": 199,
      "domain": "Security",
      "question": "A daemon app must authenticate to Azure resources without storing secrets in code. Which option should you use?",
      "options": [
        "A) Managed Identity",
        "B) Shared keys",
        "C) Client secret in appsettings.json",
        "D) User-assigned role in code"
      ],
      "multi_select": false,
      "hint": "No secrets in code.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Managed Identities allow daemon apps to securely authenticate to Azure resources without storing credentials in code. Shared keys or secrets in appsettings.json are insecure, and roles cannot be hardcoded in code."
    },
    {
      "id": 200,
      "domain": "Monitoring",
      "question": "You want to automatically collect diagnostic logs and send them to Log Analytics for a Function App. What should you configure?",
      "options": [
        "A) Activity Log",
        "B) Application Insights Profiler",
        "C) Diagnostic Settings",
        "D) Live Metrics Stream"
      ],
      "multi_select": false,
      "hint": "Per-resource logging configuration.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Diagnostic Settings on a resource configure the collection of logs and metrics to destinations like Log Analytics, Storage, or Event Hub. Activity Logs capture control-plane events, Profiler samples performance, and Live Metrics shows real-time telemetry."
    },
    {
      "id": 201,
      "domain": "Storage",
      "question": "You are designing an app that stores photos in Azure Blob Storage. Each photo must include metadata for GPS coordinates and weather conditions. The metadata should be retrievable and updatable without renaming the blob. Which approach should you use?",
      "options": [
        "A) Append metadata as a suffix to blob names",
        "B) Use metadata headers with a POST request",
        "C) Use metadata headers with a PUT request",
        "D) Store metadata in container names"
      ],
      "multi_select": false,
      "hint": "Blob metadata supports up to 8 KB.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Blob metadata is stored as key-value pairs, up to 8 KB, and can be updated independently of the blob name. It is set with PUT requests, not POST. Appending metadata to blob names is not scalable."
    },
    {
      "id": 202,
      "domain": "Compute",
      "question": "You must run a short-lived container workload that starts quickly, requires no orchestration, and will be deleted after 12 hours. Which Azure service should you use?",
      "options": [
        "A) Azure Kubernetes Service (AKS)",
        "B) Azure Container Instances (ACI)",
        "C) Azure Container Apps",
        "D) App Service Linux"
      ],
      "multi_select": false,
      "hint": "Think ephemeral workloads.",
      "correct_answers": [
        "B"
      ],
      "explanation": "ACI is designed for fast-starting, short-lived containers with no orchestration needs. AKS and Container Apps provide orchestration, while App Service is focused on long-running apps."
    },
    {
      "id": 203,
      "domain": "Storage",
      "question": "You have a blob in the Archive tier. You need to rehydrate the blob so that it can be read immediately. Which two actions can you perform?",
      "options": [
        "A) Copy the blob into Hot or Cool tier using Copy Blob",
        "B) Change the tier with Set Blob Properties",
        "C) Change the tier with Set Blob Tier",
        "D) Copy the blob using Snapshot Blob"
      ],
      "multi_select": true,
      "hint": "There are two supported rehydration paths.",
      "correct_answers": [
        "A",
        "C"
      ],
      "explanation": "Archive blobs can be rehydrated by copying them into a hot tier with Copy Blob or by using Set Blob Tier. Set Blob Properties cannot change tiers and snapshots don’t rehydrate."
    },
    {
      "id": 204,
      "domain": "Security",
      "question": "You are developing an API hosted in Azure App Service. The API must access secrets in Azure Key Vault without storing credentials in code or configuration files. Which solution should you use?",
      "options": [
        "A) Managed Identity",
        "B) Store secrets in App Settings",
        "C) Hardcode secrets in code",
        "D) Use FTP to upload credentials"
      ],
      "multi_select": false,
      "hint": "Azure-first approach for secretless access.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Managed Identity provides secure access to Azure resources without credentials. Storing or hardcoding secrets is insecure, and FTP provides no secret management."
    },
    {
      "id": 205,
      "domain": "Monitoring",
      "question": "You are troubleshooting performance issues in a production Azure Web App. You need to identify performance bottlenecks in code execution. Which Application Insights feature should you use?",
      "options": [
        "A) Snapshot Debugger",
        "B) Profiler",
        "C) Metrics Explorer",
        "D) Live Metrics"
      ],
      "multi_select": false,
      "hint": "Think performance, not debugging exceptions.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Application Insights Profiler samples running code to identify performance hotspots. Snapshot Debugger is for exceptions, Metrics Explorer visualizes metrics, and Live Metrics shows real-time telemetry."
    },
    {
      "id": 206,
      "domain": "Integration",
      "question": "A Logic App must trigger when a new file is uploaded to Blob Storage. Which trigger is most efficient?",
      "options": [
        "A) Recurrence trigger with polling",
        "B) Event Grid trigger",
        "C) Queue Storage trigger",
        "D) Service Bus trigger"
      ],
      "multi_select": false,
      "hint": "Push vs pull.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Event Grid triggers push events directly to Logic Apps, providing low-latency and efficiency. Polling is costly, and Queue/Service Bus triggers require explicit integration not provided by Blob events."
    },
    {
      "id": 207,
      "domain": "Compute",
      "question": "You are building a Durable Function workflow that runs several tasks in parallel and aggregates results at the end. Which pattern should you use?",
      "options": [
        "A) Chaining",
        "B) Fan-out/fan-in",
        "C) Async HTTP API",
        "D) External events"
      ],
      "multi_select": false,
      "hint": "Think parallelism with aggregation.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Fan-out/fan-in executes parallel activities and aggregates results. Chaining is sequential, Async HTTP API is for polling, and External Events wait for signals."
    },
    {
      "id": 208,
      "domain": "IaaS",
      "question": "You are writing a Bicep template. You need to reference an already deployed resource without recreating it. Which keyword should you use?",
      "options": [
        "A) resource",
        "B) existing",
        "C) import",
        "D) output"
      ],
      "multi_select": false,
      "hint": "For already deployed infra.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The 'existing' keyword references resources already deployed. 'resource' declares new ones, 'output' exposes values, and 'import' isn’t valid."
    },
    {
      "id": 209,
      "domain": "Security",
      "question": "You are designing authentication for a single-page application (SPA). Which OAuth2 flow should you implement?",
      "options": [
        "A) Client Credentials",
        "B) Authorization Code with PKCE",
        "C) Device Code",
        "D) Implicit"
      ],
      "multi_select": false,
      "hint": "Implicit is deprecated.",
      "correct_answers": [
        "B"
      ],
      "explanation": "SPAs should use Authorization Code with PKCE. Implicit flow is deprecated, Client Credentials is for daemons, and Device Code is for limited input devices."
    },
    {
      "id": 210,
      "domain": "Monitoring",
      "question": "You need to analyze logs from multiple subscriptions using KQL queries. Which Azure service should you use?",
      "options": [
        "A) Azure Monitor Metrics",
        "B) Log Analytics Workspace",
        "C) Application Insights Profiler",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Central log store.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Log Analytics Workspace centralizes logs across subscriptions and supports KQL queries. Metrics monitor counters, Profiler samples performance, and Alerts notify on conditions."
    },
    {
      "id": 211,
      "domain": "Storage",
      "question": "You have an app that uploads large video files to Azure Blob Storage. You need to ensure that if the upload fails partway through, the client can resume uploading from the last successful block. Which feature should you use?",
      "options": [
        "A) Append blobs",
        "B) Page blobs",
        "C) Block blobs with Put Block and Put Block List",
        "D) Blob soft delete"
      ],
      "multi_select": false,
      "hint": "Think resumable uploads.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Block blobs allow uploading in blocks, and uncommitted blocks can be resumed with Put Block and finalized with Put Block List. Append and page blobs are not suited, and soft delete is for recovery, not resumability."
    },
    {
      "id": 212,
      "domain": "Storage",
      "question": "You are writing code to download blob content. The operation must retry automatically on transient failures. Which SDK configuration should you apply?",
      "options": [
        "A) Use BlobClientOptions with Retry policy",
        "B) Call DownloadContent() directly with no options",
        "C) Use a Snapshot blob and reattempt",
        "D) Add retry logic in blob metadata"
      ],
      "multi_select": false,
      "hint": "Think SDK-level retry.",
      "correct_answers": [
        "A"
      ],
      "explanation": "BlobClientOptions allows configuring retry count and delay for transient failures. Snapshot and metadata are unrelated, and using DownloadContent without options won’t retry automatically."
    },
    {
      "id": 213,
      "domain": "Storage",
      "question": "Your app must prevent overwriting an existing blob if one already exists. Which request condition should you use?",
      "options": [
        "A) Overwrite = false",
        "B) If-None-Match = * ETag",
        "C) Set Blob Tier",
        "D) Use SAS token with read-only permissions"
      ],
      "multi_select": false,
      "hint": "Conditional headers enforce this.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The If-None-Match=* condition ensures the upload succeeds only if the blob does not exist. SAS with read-only prevents writes altogether, and Blob Tier changes performance tier, not concurrency."
    },
    {
      "id": 214,
      "domain": "Storage",
      "question": "You must enforce compliance that prevents deletion or modification of blobs for 7 years. Which two Blob features should you enable?",
      "options": [
        "A) Soft delete",
        "B) Legal hold",
        "C) Time-based immutability policy",
        "D) Versioning"
      ],
      "multi_select": true,
      "hint": "Think WORM storage.",
      "correct_answers": [
        "B",
        "C"
      ],
      "explanation": "Legal holds and time-based immutability enforce WORM compliance. Soft delete allows recovery but does not prevent deletion, and versioning tracks history but does not enforce retention."
    },
    {
      "id": 215,
      "domain": "Storage",
      "question": "You are designing Cosmos DB collections to support even distribution of requests. Which key choice is best?",
      "options": [
        "A) A constant value such as 'UK'",
        "B) A high-cardinality property such as UserId",
        "C) A property with only two values, 'Yes' or 'No'",
        "D) The timestamp when data was created"
      ],
      "multi_select": false,
      "hint": "Avoid hot partitions.",
      "correct_answers": [
        "B"
      ],
      "explanation": "High-cardinality keys like UserId spread requests evenly. Constant values or binary properties cause hot partitions. Timestamp can skew data by time."
    },
    {
      "id": 216,
      "domain": "Compute",
      "question": "You must deploy an Azure Function that only runs when messages arrive in a Storage Queue. The function must scale automatically with queue length. Which trigger should you use?",
      "options": [
        "A) Timer trigger",
        "B) Queue Storage trigger",
        "C) Event Grid trigger",
        "D) HTTP trigger"
      ],
      "multi_select": false,
      "hint": "Scales based on queue length.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Queue Storage trigger scales function instances automatically with queue size. Timer is scheduled, Event Grid is event-driven, HTTP responds to requests."
    },
    {
      "id": 217,
      "domain": "Compute",
      "question": "You are designing a Durable Function that starts with an HTTP request and must return a 202 Accepted response with a status endpoint. Which pattern should you use?",
      "options": [
        "A) Chaining",
        "B) Fan-out/fan-in",
        "C) Async HTTP API",
        "D) External events"
      ],
      "multi_select": false,
      "hint": "Think polling pattern.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The Async HTTP API pattern returns a 202 response and a status endpoint for polling results. Chaining is sequential, fan-out/fan-in aggregates parallel work, external events wait for signals."
    },
    {
      "id": 218,
      "domain": "Compute",
      "question": "You must host a microservice that can scale to zero and respond to HTTP events. The service must support KEDA-based event scaling. Which platform should you use?",
      "options": [
        "A) AKS",
        "B) Azure Container Apps",
        "C) Azure Container Instances",
        "D) App Service"
      ],
      "multi_select": false,
      "hint": "Think serverless containers.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Azure Container Apps support scale-to-zero and integrate with KEDA for event-driven scaling. AKS requires Kubernetes management, ACI is single-container only, App Service does not scale to zero."
    },
    {
      "id": 219,
      "domain": "Compute",
      "question": "You need to stage a zero-downtime deployment for an App Service Web App and route 20% of traffic to a new version for testing. Which feature should you use?",
      "options": [
        "A) App Service deployment slots with traffic routing",
        "B) Azure Traffic Manager",
        "C) App Service scaling",
        "D) Availability Sets"
      ],
      "multi_select": false,
      "hint": "Blue/green style.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Deployment slots with traffic routing allow partial traffic rollout with zero downtime. Traffic Manager is DNS-based, scaling adds instances, availability sets apply only to VMs."
    },
    {
      "id": 220,
      "domain": "Compute",
      "question": "You must run a scheduled background task every hour with no infrastructure management. Which option is best?",
      "options": [
        "A) Timer trigger in Azure Functions",
        "B) Logic App recurrence trigger",
        "C) AKS CronJob",
        "D) Continuous WebJob"
      ],
      "multi_select": false,
      "hint": "Think serverless scheduling.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Timer trigger Functions provide serverless scheduling. Logic Apps recurrence is also valid but used for integration scenarios. AKS requires Kubernetes overhead, WebJobs require App Service hosting."
    },
    {
      "id": 221,
      "domain": "Security",
      "question": "You are registering an API in Azure AD that must be accessible by multiple external organizations. Which app type should you configure?",
      "options": [
        "A) Single-tenant app",
        "B) Multi-tenant app",
        "C) Managed identity",
        "D) Service principal only"
      ],
      "multi_select": false,
      "hint": "Cross-org access.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Multi-tenant apps allow sign-in from any Azure AD tenant. Single-tenant apps restrict access. Managed identity is for Azure-hosted resources, service principals are identities but not app registrations."
    },
    {
      "id": 222,
      "domain": "Security",
      "question": "An Azure Function must access Key Vault secrets. Microsoft recommends moving away from access policies. Which model should you implement?",
      "options": [
        "A) Role-based access control (RBAC)",
        "B) IP firewall rules",
        "C) Access policies only",
        "D) Public endpoint"
      ],
      "multi_select": false,
      "hint": "Align with Azure-wide RBAC.",
      "correct_answers": [
        "A"
      ],
      "explanation": "RBAC is now the recommended access model for Key Vault. Access policies are legacy. Firewalls only control networking, and public endpoints don’t manage access."
    },
    {
      "id": 223,
      "domain": "Security",
      "question": "You are designing an OAuth flow for a daemon app that runs without user interaction. Which flow should you use?",
      "options": [
        "A) Authorization Code with PKCE",
        "B) Client Credentials",
        "C) Device Code",
        "D) Implicit"
      ],
      "multi_select": false,
      "hint": "No user present.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Daemon apps should use Client Credentials flow with an app identity. PKCE is for SPAs, Device Code for limited input devices, Implicit is deprecated."
    },
    {
      "id": 224,
      "domain": "Security",
      "question": "Which two claims must an API validate in incoming JWT tokens to ensure security?",
      "options": [
        "A) Audience (aud)",
        "B) Issuer (iss)",
        "C) Resource Group",
        "D) Subscription ID"
      ],
      "multi_select": true,
      "hint": "Who issued it, who it’s for.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "APIs should validate the 'aud' claim to ensure the token is intended for them and the 'iss' claim to ensure it was issued by a trusted authority. Resource Group and Subscription ID are irrelevant to token validation."
    },
    {
      "id": 225,
      "domain": "Monitoring",
      "question": "You need to configure Azure Monitor so that all diagnostic logs from a storage account are sent to a central workspace. What should you configure?",
      "options": [
        "A) Action Groups",
        "B) Diagnostic settings",
        "C) Metric alerts",
        "D) Application Insights"
      ],
      "multi_select": false,
      "hint": "Per-resource log routing.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Diagnostic settings define destinations for logs and metrics, such as Log Analytics. Action groups define responses, metric alerts trigger on thresholds, Application Insights is app telemetry not resource logs."
    },
    {
      "id": 226,
      "domain": "Monitoring",
      "question": "You must capture all exception telemetry while still reducing volume of normal telemetry. Which Application Insights feature should you configure?",
      "options": [
        "A) Fixed sampling",
        "B) Adaptive sampling with exception exclusions",
        "C) Disable sampling",
        "D) Live Metrics"
      ],
      "multi_select": false,
      "hint": "Keep all errors, reduce noise.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Adaptive sampling can keep all exceptions while reducing other telemetry. Fixed sampling may drop errors, disabling sampling is too costly, Live Metrics shows real-time data but not retention."
    },
    {
      "id": 227,
      "domain": "Monitoring",
      "question": "You need to alert when a VM deletion occurs in your subscription. Which alert type should you use?",
      "options": [
        "A) Metric alert",
        "B) Activity log alert",
        "C) Log query alert",
        "D) Action group"
      ],
      "multi_select": false,
      "hint": "Think control-plane operations.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Activity log alerts trigger on control-plane operations like resource creation/deletion. Metric alerts monitor performance, log query alerts apply to KQL queries, action groups define responses."
    },
    {
      "id": 228,
      "domain": "Integration",
      "question": "You are publishing partner APIs through Azure API Management. You must enforce JWT validation, rate limits, and usage quotas. Which service and policy combination should you use?",
      "options": [
        "A) Azure Front Door with caching",
        "B) API Management with validate-jwt, rate-limit, and quota policies",
        "C) Application Gateway with WAF",
        "D) Azure Functions proxies"
      ],
      "multi_select": false,
      "hint": "Think full API gateway.",
      "correct_answers": [
        "B"
      ],
      "explanation": "API Management supports JWT validation and throttling policies. Front Door and Application Gateway operate at network/routing level, Functions proxies are lightweight and don’t provide full API governance."
    },
    {
      "id": 229,
      "domain": "Integration",
      "question": "You need to ingest millions of telemetry events per second from IoT devices into Azure. Which service should you use?",
      "options": [
        "A) Service Bus",
        "B) Event Hubs",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "High-throughput telemetry.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Event Hubs is designed for telemetry ingestion at scale. Service Bus is enterprise messaging, Event Grid is lightweight pub/sub, Queue Storage is basic queuing."
    },
    {
      "id": 230,
      "domain": "IaaS",
      "question": "You are deploying a Bicep template and want to preview changes without applying them. Which Azure CLI command should you use?",
      "options": [
        "A) az deployment group create",
        "B) az bicep build",
        "C) az deployment group what-if",
        "D) az resource show"
      ],
      "multi_select": false,
      "hint": "Dry-run preview.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The 'what-if' command previews changes before deployment. 'create' applies them, 'bicep build' compiles Bicep to ARM JSON, and 'resource show' inspects resources."
    },
    {
      "id": 231,
      "domain": "Compute",
      "question": "Arrange the correct order to deploy an Azure Function that triggers when a blob is created.",
      "options": [
        "A) Create a Function App with a Storage Account connection",
        "B) Configure the Function trigger for Blob Storage",
        "C) Deploy code from VS Code or GitHub",
        "D) Upload a test blob to verify trigger"
      ],
      "multi_select": false,
      "hint": "Think deployment lifecycle from resource creation to validation.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "First create the Function App and storage binding, then configure the blob trigger, deploy your code, and finally test by uploading a blob."
    },
    {
      "id": 232,
      "domain": "Compute",
      "question": "You must build an HTTP-triggered Azure Function that requires authentication and scales automatically. Which hosting plan should you choose?",
      "options": [
        "A) Consumption plan",
        "B) Premium plan",
        "C) Dedicated plan",
        "D) Kubernetes with Functions runtime"
      ],
      "multi_select": false,
      "hint": "You need auto-scaling and minimal cost; cold starts are acceptable.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Consumption plan offers serverless scaling and pay-per-execution. Premium avoids cold starts but costs more; Dedicated is fixed; Kubernetes adds management overhead."
    },
    {
      "id": 233,
      "domain": "Integration",
      "question": "Complete the missing CLI flag: az ____ topic create --name myTopic --resource-group myRG --location eastus",
      "options": [
        "A) eventgrid",
        "B) azeventgrid",
        "C) event",
        "D) eg"
      ],
      "multi_select": false,
      "hint": "Service name used for event routing.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'eventgrid' subcommand is used to manage Azure Event Grid resources such as topics and domains."
    },
    {
      "id": 234,
      "domain": "Integration",
      "question": "Your application must broadcast notifications when a new file is uploaded to Blob Storage. Which Azure service provides lowest latency and fan-out delivery?",
      "options": [
        "A) Event Grid",
        "B) Service Bus",
        "C) Event Hubs",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Think lightweight pub/sub eventing.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid delivers lightweight publish-subscribe event routing with low latency and supports multiple subscribers."
    },
    {
      "id": 235,
      "domain": "Compute",
      "question": "Which trigger type automatically scales function instances based on the number of pending messages?",
      "options": [
        "A) Timer trigger",
        "B) Queue Storage trigger",
        "C) HTTP trigger",
        "D) Event Grid trigger"
      ],
      "multi_select": false,
      "hint": "Think of workload-driven scaling.",
      "correct_answers": [
        "B"
      ],
      "explanation": "Queue triggers scale the number of function instances based on queue depth, enabling elastic message processing."
    },
    {
      "id": 236,
      "domain": "Compute",
      "question": "You need to deploy a containerized microservice that must start instantly and can be deleted after testing. Which service fits best?",
      "options": [
        "A) Azure Container Instances",
        "B) Azure Kubernetes Service",
        "C) Azure Container Apps",
        "D) App Service Linux"
      ],
      "multi_select": false,
      "hint": "Ephemeral, single container.",
      "correct_answers": [
        "A"
      ],
      "explanation": "ACI runs containers on demand without orchestration overhead and is ideal for short-lived workloads."
    },
    {
      "id": 237,
      "domain": "Compute",
      "question": "Arrange the steps to deploy a containerized web API to Azure Container Apps using Azure CLI.",
      "options": [
        "A) az containerapp create",
        "B) az acr build --image api:v1",
        "C) az acr push api:v1",
        "D) az containerapp up"
      ],
      "multi_select": false,
      "hint": "Build → Push → Deploy → Verify.",
      "correct_answers": [
        "B",
        "C",
        "A",
        "D"
      ],
      "explanation": "Build the image locally or in ACR, push it to registry, create the container app, then deploy and verify it with 'containerapp up'."
    },
    {
      "id": 238,
      "domain": "Integration",
      "question": "You must ensure ordered message delivery and support dead-letter queues. Which service should you use?",
      "options": [
        "A) Service Bus",
        "B) Event Grid",
        "C) Event Hubs",
        "D) Storage Queue"
      ],
      "multi_select": false,
      "hint": "Enterprise messaging with FIFO.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Service Bus supports FIFO via sessions and provides dead-letter queues for failed message processing."
    },
    {
      "id": 239,
      "domain": "Storage",
      "question": "Arrange the correct steps to securely upload a file to Blob Storage using SAS.",
      "options": [
        "A) Generate SAS token with permissions and expiry",
        "B) Append SAS token to the blob URL",
        "C) Perform PUT or POST request with file content",
        "D) Revoke SAS if no longer needed"
      ],
      "multi_select": false,
      "hint": "Sequence from generating access to cleanup.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "You first generate the SAS, then combine it with the blob URL, upload your file, and revoke it if no longer needed for security."
    },
    {
      "id": 240,
      "domain": "Security",
      "question": "Complete the missing CLI flag: az role assignment create ____ <identityId> --role 'Key Vault Secrets User' --scope <vaultId>",
      "options": [
        "A) --assignee",
        "B) --user",
        "C) --principal",
        "D) --identity"
      ],
      "multi_select": false,
      "hint": "Flag used to specify the target identity.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The '--assignee' flag identifies which user, group, or managed identity receives the role assignment."
    },
    {
      "id": 241,
      "domain": "Integration",
      "question": "Your Logic App should respond to an Event Grid event when a blob is added. Which trigger should you choose?",
      "options": [
        "A) Event Grid trigger",
        "B) Recurrence trigger",
        "C) HTTP trigger",
        "D) Queue Storage trigger"
      ],
      "multi_select": false,
      "hint": "Push-based event reaction.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid trigger enables Logic Apps to react instantly to blob creation events."
    },
    {
      "id": 242,
      "domain": "Monitoring",
      "question": "Which Application Insights feature allows you to see current requests and failure rates in real time?",
      "options": [
        "A) Live Metrics Stream",
        "B) Profiler",
        "C) Snapshot Debugger",
        "D) Workbooks"
      ],
      "multi_select": false,
      "hint": "Think live telemetry.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Live Metrics Stream provides near real-time insights into incoming requests and failures."
    },
    {
      "id": 243,
      "domain": "Storage",
      "question": "You need to replicate data across regions with multi-master writes in Cosmos DB. Which feature enables this?",
      "options": [
        "A) Multi-region writes",
        "B) Change feed",
        "C) Session consistency",
        "D) Autoscale throughput"
      ],
      "multi_select": false,
      "hint": "Also known as active-active replication.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Multi-region writes allow Cosmos DB to accept writes in multiple regions with conflict resolution."
    },
    {
      "id": 244,
      "domain": "Security",
      "question": "Which two claims should an API validate in a JWT token to confirm authenticity?",
      "options": [
        "A) iss",
        "B) aud",
        "C) exp",
        "D) typ"
      ],
      "multi_select": true,
      "hint": "Issuer and intended audience.",
      "correct_answers": [
        "A",
        "B"
      ],
      "explanation": "APIs validate 'iss' for trusted issuer and 'aud' for intended recipient to ensure token authenticity."
    },
    {
      "id": 245,
      "domain": "Compute",
      "question": "A function must call another function only after all parallel tasks finish. Which Durable Functions pattern should you use?",
      "options": [
        "A) Fan-out/fan-in",
        "B) Async HTTP API",
        "C) External events",
        "D) Chaining"
      ],
      "multi_select": false,
      "hint": "Aggregate parallel results.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Fan-out/fan-in pattern executes tasks in parallel and aggregates results before proceeding."
    },
    {
      "id": 246,
      "domain": "Integration",
      "question": "Complete the missing command to create a Service Bus namespace.",
      "options": [
        "A) az servicebus namespace create --name myNS --resource-group myRG --location westeurope",
        "B) az servicebus create namespace myNS",
        "C) az namespace servicebus new myRG myNS",
        "D) az bus create ns myNS"
      ],
      "multi_select": false,
      "hint": "Order is service → noun → create.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The correct syntax is 'az servicebus namespace create' with name, RG, and location."
    },
    {
      "id": 247,
      "domain": "Compute",
      "question": "You are asked to deploy multiple containers that must communicate internally with service discovery and autoscaling. Which service should you choose?",
      "options": [
        "A) AKS",
        "B) ACI",
        "C) Container Apps",
        "D) Functions"
      ],
      "multi_select": false,
      "hint": "Full orchestration required.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Azure Kubernetes Service provides full orchestration, internal networking, and autoscaling for multi-container deployments."
    },
    {
      "id": 248,
      "domain": "Compute",
      "question": "In a Function App, which setting prevents cold starts by keeping instances warm?",
      "options": [
        "A) Always On",
        "B) WEBSITE_RUN_FROM_PACKAGE",
        "C) SCM_DO_BUILD_DURING_DEPLOYMENT",
        "D) WEBSITE_NODE_DEFAULT_VERSION"
      ],
      "multi_select": false,
      "hint": "Used for Premium and Dedicated plans.",
      "correct_answers": [
        "A"
      ],
      "explanation": "'Always On' keeps Function App instances warm, minimizing cold start delays on Premium/Dedicated plans."
    },
    {
      "id": 249,
      "domain": "Integration",
      "question": "Arrange the order to configure an Event Grid subscription for a Function endpoint.",
      "options": [
        "A) Get Function URL",
        "B) Create Event Grid Topic",
        "C) Create Event Subscription referencing the Function endpoint",
        "D) Validate the subscription handshake"
      ],
      "multi_select": false,
      "hint": "Topic before subscription.",
      "correct_answers": [
        "B",
        "A",
        "C",
        "D"
      ],
      "explanation": "Create the topic, retrieve Function endpoint, then subscribe and complete validation handshake."
    },
    {
      "id": 250,
      "domain": "Security",
      "question": "Which Azure feature injects Key Vault secrets into App Service environment variables without code changes?",
      "options": [
        "A) Key Vault references in app settings",
        "B) Managed Identity only",
        "C) SDK call in startup code",
        "D) FTP publish"
      ],
      "multi_select": false,
      "hint": "@Microsoft.KeyVault syntax.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Key Vault references in configuration use '@Microsoft.KeyVault' syntax to inject secrets automatically."
    },
    {
      "id": 251,
      "domain": "Monitoring",
      "question": "You want to visualize CPU usage for a Function App over time using KQL. Which tool should you use?",
      "options": [
        "A) Workbooks",
        "B) Metrics Explorer",
        "C) Log Analytics",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Dashboards with KQL and charts.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Workbooks allow KQL queries and visualizations across metrics and logs."
    },
    {
      "id": 252,
      "domain": "Storage",
      "question": "Which blob storage feature ensures data cannot be modified for a specified retention period?",
      "options": [
        "A) Immutable Storage (Time-based retention)",
        "B) Versioning",
        "C) Soft Delete",
        "D) Archive Tier"
      ],
      "multi_select": false,
      "hint": "WORM compliance.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Immutable storage prevents modification or deletion for the set retention time, ensuring compliance."
    },
    {
      "id": 253,
      "domain": "IaaS",
      "question": "Which Bicep command previews a deployment without applying it?",
      "options": [
        "A) az deployment group what-if",
        "B) az bicep build",
        "C) az resource show",
        "D) az group validate"
      ],
      "multi_select": false,
      "hint": "Dry-run check.",
      "correct_answers": [
        "A"
      ],
      "explanation": "'az deployment group what-if' previews resource changes for safe review before deployment."
    },
    {
      "id": 254,
      "domain": "Integration",
      "question": "You must design a system that reacts to millions of telemetry events per second. Which service is most appropriate?",
      "options": [
        "A) Event Hubs",
        "B) Service Bus",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Streaming ingestion.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Hubs handles massive throughput for telemetry ingestion and analytics pipelines."
    },
    {
      "id": 255,
      "domain": "Compute",
      "question": "Which Durable Functions pattern waits for external approval before proceeding?",
      "options": [
        "A) External Events",
        "B) Async HTTP API",
        "C) Fan-out/fan-in",
        "D) Chaining"
      ],
      "multi_select": false,
      "hint": "Pause until external input.",
      "correct_answers": [
        "A"
      ],
      "explanation": "External Events pattern pauses workflows until an external signal or approval is received."
    },
    {
      "id": 256,
      "domain": "Monitoring",
      "question": "Which Application Insights feature helps you diagnose slow dependencies in production?",
      "options": [
        "A) Profiler",
        "B) Snapshot Debugger",
        "C) Live Metrics",
        "D) Alerts"
      ],
      "multi_select": false,
      "hint": "Performance sampling.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Profiler samples production requests to identify performance bottlenecks in code or dependencies."
    },
    {
      "id": 257,
      "domain": "Security",
      "question": "Arrange the steps to allow a Function App to read secrets from Key Vault using Managed Identity.",
      "options": [
        "A) Enable system-assigned Managed Identity on Function App",
        "B) Assign Key Vault Secrets User role to the identity",
        "C) Add secret reference in configuration",
        "D) Restart the Function App"
      ],
      "multi_select": false,
      "hint": "Enable → assign → configure → restart.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Enable the identity, grant it role access, configure the secret reference, and restart the app to load the setting."
    },
    {
      "id": 258,
      "domain": "IaaS",
      "question": "You must reuse an existing Resource Group and Key Vault in a Bicep template. Which keyword do you use?",
      "options": [
        "A) existing",
        "B) import",
        "C) output",
        "D) reference"
      ],
      "multi_select": false,
      "hint": "No redeployment.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'existing' keyword references already-deployed resources in Bicep without recreating them."
    },
    {
      "id": 259,
      "domain": "Integration",
      "question": "Complete the missing CLI flag: az functionapp create --resource-group myRG --consumption-plan-location westeurope --runtime node --functions-version 4 ____ myFunc",
      "options": [
        "A) --name",
        "B) --app-name",
        "C) --new",
        "D) --alias"
      ],
      "multi_select": false,
      "hint": "Naming flag for app creation.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'az functionapp create' command uses '--name' to specify the Function App name."
    },
    {
      "id": 260,
      "domain": "Storage",
      "question": "Your app must trigger an Event Grid event when a blob is deleted. Which event type should you subscribe to?",
      "options": [
        "A) Microsoft.Storage.BlobDeleted",
        "B) Microsoft.Storage.BlobCreated",
        "C) Microsoft.Storage.BlobRenamed",
        "D) Microsoft.Storage.ContainerDeleted"
      ],
      "multi_select": false,
      "hint": "Think about the operation performed.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Microsoft.Storage.BlobDeleted event triggers when a blob is deleted from a container."
    },
    {
      "id": 261,
      "domain": "Compute",
      "question": "You’re creating a timer-triggered Azure Function that runs every 15 minutes. Which CRON expression should you use?",
      "options": [
        "A) 0 */15 * * * *",
        "B) */15 0 * * * *",
        "C) 15 * * * * *",
        "D) 0 0/15 * * * *"
      ],
      "multi_select": false,
      "hint": "Azure Functions CRON syntax uses 6 fields (seconds included).",
      "correct_answers": [
        "A"
      ],
      "explanation": "In Azure Functions, '0 */15 * * * *' means trigger every 15 minutes starting at 0 seconds."
    },
    {
      "id": 262,
      "domain": "Integration",
      "question": "You must process messages in batches from an Event Hub stream. Which SDK feature should you use?",
      "options": [
        "A) EventProcessorClient",
        "B) ServiceBusReceiver",
        "C) EventHubProducerClient",
        "D) QueueClient"
      ],
      "multi_select": false,
      "hint": "Think of consumer group scaling.",
      "correct_answers": [
        "A"
      ],
      "explanation": "EventProcessorClient handles receiving and processing Event Hub messages in parallel across partitions."
    },
    {
      "id": 263,
      "domain": "Compute",
      "question": "Arrange the steps to deploy an AKS cluster using the Azure CLI.",
      "options": [
        "A) az aks create --resource-group myRG --name myAKS --node-count 2 --enable-addons monitoring",
        "B) az aks get-credentials --resource-group myRG --name myAKS",
        "C) az group create --name myRG --location westeurope",
        "D) kubectl get nodes"
      ],
      "multi_select": false,
      "hint": "Create RG → create cluster → connect → verify.",
      "correct_answers": [
        "C",
        "A",
        "B",
        "D"
      ],
      "explanation": "You must first create a resource group, then deploy AKS, retrieve credentials, and verify the nodes using kubectl."
    },
    {
      "id": 264,
      "domain": "Security",
      "question": "Your API deployed in App Service must use Azure AD for authentication. What should you configure first in Azure AD?",
      "options": [
        "A) App registration",
        "B) Managed identity",
        "C) Conditional Access policy",
        "D) Service principal password"
      ],
      "multi_select": false,
      "hint": "Every secured API starts with this.",
      "correct_answers": [
        "A"
      ],
      "explanation": "An App registration defines an identity for the API in Azure AD and issues tokens for client authentication."
    },
    {
      "id": 265,
      "domain": "Integration",
      "question": "Which feature of Service Bus helps ensure that only one consumer processes messages from a specific group?",
      "options": [
        "A) Sessions",
        "B) Topics",
        "C) Dead-letter queues",
        "D) Auto-forwarding"
      ],
      "multi_select": false,
      "hint": "Provides FIFO and message grouping.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Service Bus sessions group related messages and ensure ordered, single-consumer processing."
    },
    {
      "id": 266,
      "domain": "Storage",
      "question": "You must automatically delete old blob versions after 90 days. Which feature enables this?",
      "options": [
        "A) Lifecycle management policy",
        "B) Immutable storage",
        "C) Soft delete",
        "D) Versioning"
      ],
      "multi_select": false,
      "hint": "Automation via JSON rules.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Blob lifecycle management allows you to define rules that delete or move blobs after a retention period."
    },
    {
      "id": 267,
      "domain": "Monitoring",
      "question": "You need to send custom logs from an application to Log Analytics. Which API endpoint should you use?",
      "options": [
        "A) Data Collector API",
        "B) Application Insights TrackTrace",
        "C) Diagnostic settings API",
        "D) Event Hub export"
      ],
      "multi_select": false,
      "hint": "HTTP endpoint for custom JSON payloads.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Log Analytics Data Collector API allows sending custom JSON logs directly to a workspace."
    },
    {
      "id": 268,
      "domain": "Security",
      "question": "You need to grant an Azure Function access to a specific Key Vault secret. Which two steps are required?",
      "options": [
        "A) Enable managed identity on the Function App",
        "B) Add the Function App's name to the Key Vault access policy",
        "C) Assign Key Vault Secrets User role at the vault scope",
        "D) Include the vault connection string in code"
      ],
      "multi_select": true,
      "hint": "One enables identity, one grants access.",
      "correct_answers": [
        "A",
        "C"
      ],
      "explanation": "Enable managed identity, then grant the identity the 'Key Vault Secrets User' role at the vault scope."
    },
    {
      "id": 269,
      "domain": "Compute",
      "question": "Complete the missing parameter: az functionapp deploy --src-path ./publish --resource-group myRG --name myFuncApp ____ zip",
      "options": [
        "A) --type",
        "B) --format",
        "C) --deploy-type",
        "D) --file"
      ],
      "multi_select": false,
      "hint": "Specifies the deployment method.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The correct syntax is 'az functionapp deploy --type zip' to push a ZIP package deployment."
    },
    {
      "id": 270,
      "domain": "Integration",
      "question": "Your Function App must consume messages from a Service Bus queue. Which binding direction should you use?",
      "options": [
        "A) trigger",
        "B) in",
        "C) out",
        "D) both"
      ],
      "multi_select": false,
      "hint": "It starts the function when a message arrives.",
      "correct_answers": [
        "A"
      ],
      "explanation": "A Service Bus trigger activates the function when a message arrives on the queue."
    },
    {
      "id": 271,
      "domain": "Storage",
      "question": "Which Cosmos DB consistency level provides the best balance between performance and data accuracy?",
      "options": [
        "A) Session",
        "B) Strong",
        "C) Eventual",
        "D) Consistent Prefix"
      ],
      "multi_select": false,
      "hint": "Default option for SDKs.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Session consistency ensures reads are consistent within a single session while maintaining good performance."
    },
    {
      "id": 272,
      "domain": "Monitoring",
      "question": "Arrange the steps to configure diagnostic logs for an App Service to send to Log Analytics.",
      "options": [
        "A) Create a Log Analytics workspace",
        "B) Enable diagnostic settings on App Service",
        "C) Choose the Log Analytics destination",
        "D) Save the configuration"
      ],
      "multi_select": false,
      "hint": "Workspace first, then diagnostic setup.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "You must create the workspace, configure diagnostics, select the destination, and save the settings."
    },
    {
      "id": 273,
      "domain": "Compute",
      "question": "You are debugging an Azure Function and need to view real-time logs from the command line. Which command do you use?",
      "options": [
        "A) func start",
        "B) func logs",
        "C) func azure functionapp logstream",
        "D) func watch"
      ],
      "multi_select": false,
      "hint": "Streams logs from deployed app.",
      "correct_answers": [
        "C"
      ],
      "explanation": "The 'func azure functionapp logstream' command streams logs directly from the deployed Function App."
    },
    {
      "id": 274,
      "domain": "Integration",
      "question": "You need to connect multiple Function Apps to the same Event Hub for different processing pipelines. What should you configure?",
      "options": [
        "A) Consumer groups",
        "B) Shared access keys",
        "C) Event subscriptions",
        "D) Partition keys"
      ],
      "multi_select": false,
      "hint": "Each independent processor uses its own view of the stream.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Consumer groups allow multiple independent applications to each read the Event Hub stream."
    },
    {
      "id": 275,
      "domain": "Security",
      "question": "Which Azure Function authentication level should you use for public HTTP endpoints that require no key?",
      "options": [
        "A) Anonymous",
        "B) Function",
        "C) Admin",
        "D) System"
      ],
      "multi_select": false,
      "hint": "Used for open APIs.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Anonymous authentication allows anyone to call the function without a key, useful for public endpoints."
    },
    {
      "id": 276,
      "domain": "IaaS",
      "question": "Your Bicep template should output the Function App hostname after deployment. Which keyword defines this?",
      "options": [
        "A) output",
        "B) reference",
        "C) export",
        "D) param"
      ],
      "multi_select": false,
      "hint": "Used to expose values after deployment.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The 'output' keyword declares a value to return after template deployment."
    },
    {
      "id": 277,
      "domain": "Integration",
      "question": "You must trigger a workflow when a message arrives on a Service Bus topic subscription. Which service can handle this with minimal code?",
      "options": [
        "A) Logic Apps",
        "B) Event Grid",
        "C) Functions",
        "D) Container Apps"
      ],
      "multi_select": false,
      "hint": "No-code or low-code orchestration tool.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Logic Apps can directly listen to Service Bus topic subscriptions and orchestrate downstream actions."
    },
    {
      "id": 278,
      "domain": "Compute",
      "question": "Which Durable Functions feature enables long-running workflows to persist state efficiently?",
      "options": [
        "A) Orchestrator function",
        "B) Sub-orchestration",
        "C) Entity functions",
        "D) Chaining pattern"
      ],
      "multi_select": false,
      "hint": "Stores lightweight state across invocations.",
      "correct_answers": [
        "C"
      ],
      "explanation": "Entity functions represent stateful objects within Durable Functions and persist automatically."
    },
    {
      "id": 279,
      "domain": "Monitoring",
      "question": "You want to automatically scale an App Service based on CPU usage. What must you configure?",
      "options": [
        "A) Autoscale rule in App Service plan",
        "B) ARM lock",
        "C) Availability set",
        "D) Resource health alert"
      ],
      "multi_select": false,
      "hint": "Managed at plan level.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Autoscale rules are defined on the App Service plan to scale instances dynamically based on metrics."
    },
    {
      "id": 280,
      "domain": "Storage",
      "question": "You need to store large binary files and access them via a custom domain over HTTPS. What combination should you use?",
      "options": [
        "A) Azure Blob Storage + CDN + Custom Domain",
        "B) Azure Files + Private Link",
        "C) Disk Storage + HTTPS endpoint",
        "D) Queue Storage + Access Keys"
      ],
      "multi_select": false,
      "hint": "Think scalable and public delivery.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Blob Storage with a CDN and custom domain provides secure HTTPS access and global performance."
    },
    {
      "id": 281,
      "domain": "Compute",
      "question": "Case Study: A health-tracking app stores user uploads in Blob Storage and processes them with an Azure Function. The function must scale automatically and process files within seconds.\n\nWhich hosting plan meets the requirement?",
      "options": [
        "A) Consumption plan",
        "B) Premium plan",
        "C) Dedicated plan",
        "D) App Service Environment"
      ],
      "multi_select": false,
      "hint": "Cold starts matter if near-real-time processing is required.",
      "correct_answers": [
        "B"
      ],
      "explanation": "The Premium plan avoids cold starts and provides predictable scaling for latency-sensitive workloads."
    },
    {
      "id": 282,
      "domain": "Integration",
      "question": "Arrange the steps to connect a Function App to Event Grid to process blob-created events.",
      "options": [
        "A) Create Event Grid subscription",
        "B) Enable system-assigned identity on Function App",
        "C) Grant EventGrid EventSubscriptionContributor role",
        "D) Validate the event subscription handshake"
      ],
      "multi_select": false,
      "hint": "Identity and permissions precede subscription creation.",
      "correct_answers": [
        "B",
        "C",
        "A",
        "D"
      ],
      "explanation": "Enable identity → grant role → create subscription → validate handshake."
    },
    {
      "id": 283,
      "domain": "Storage",
      "question": "Case Study: You manage a photo archive using Blob Storage. Legal policy requires that once uploaded, photos cannot be deleted or modified for 2 years.\n\nWhich feature should you configure?",
      "options": [
        "A) Immutable storage policy",
        "B) Soft delete",
        "C) Blob snapshots",
        "D) Versioning"
      ],
      "multi_select": false,
      "hint": "WORM compliance.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Immutable (time-based retention) prevents deletion/modification for the defined retention period."
    },
    {
      "id": 284,
      "domain": "Security",
      "question": "Arrange the steps to secure a Function App using Azure AD authentication.",
      "options": [
        "A) Register the Function App in Azure AD",
        "B) Enable Authentication under App Service settings",
        "C) Configure 'Log in with Azure Active Directory'",
        "D) Test access with a valid token"
      ],
      "multi_select": false,
      "hint": "Register → enable → configure → test.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "App registration creates the identity; then enable and configure AAD auth; finally test token access."
    },
    {
      "id": 285,
      "domain": "Compute",
      "question": "Case Study: You are containerizing a legacy web API. It must auto-scale, expose HTTPS, and handle rolling updates.\n\nWhich Azure service best fits?",
      "options": [
        "A) Azure Kubernetes Service (AKS)",
        "B) Azure Container Instances (ACI)",
        "C) Azure Container Apps",
        "D) Azure Web Apps for Containers"
      ],
      "multi_select": false,
      "hint": "Requires full orchestration and rolling updates.",
      "correct_answers": [
        "A"
      ],
      "explanation": "AKS provides orchestrated deployments, load balancing, and rolling update control."
    },
    {
      "id": 286,
      "domain": "Integration",
      "question": "Case Study: You design a messaging workflow between microservices. Each message must be delivered once and in order.\n\nWhich Azure service should you use?",
      "options": [
        "A) Service Bus with sessions",
        "B) Event Hubs",
        "C) Event Grid",
        "D) Storage Queues"
      ],
      "multi_select": false,
      "hint": "Only one service offers FIFO guarantees.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Service Bus sessions ensure ordered, exactly-once message delivery."
    },
    {
      "id": 287,
      "domain": "Monitoring",
      "question": "Arrange the steps to create a metric alert for Function execution failures.",
      "options": [
        "A) Navigate to the Function App in the portal",
        "B) Choose 'Alerts' > 'New alert rule'",
        "C) Select 'Function Execution Failures' metric",
        "D) Define threshold and action group"
      ],
      "multi_select": false,
      "hint": "Create alert rule → choose metric → set threshold → assign action.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Function App > Alerts > select metric > define rule and action group."
    },
    {
      "id": 288,
      "domain": "Compute",
      "question": "Case Study: You deploy a Function App on the Consumption plan and notice cold starts. You must eliminate cold starts while minimizing cost.\n\nWhich change achieves this?",
      "options": [
        "A) Move to Premium plan",
        "B) Enable 'Always On'",
        "C) Increase timeout",
        "D) Add extra instances manually"
      ],
      "multi_select": false,
      "hint": "Only one plan supports pre-warmed instances.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Premium plan maintains pre-warmed instances to prevent cold starts."
    },
    {
      "id": 289,
      "domain": "Integration",
      "question": "Arrange the correct deployment flow for a Logic App that listens to Event Grid and sends alerts via Teams.",
      "options": [
        "A) Create Logic App",
        "B) Add Event Grid trigger",
        "C) Add Teams connector action",
        "D) Deploy and test"
      ],
      "multi_select": false,
      "hint": "Trigger before action, deployment last.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Build Logic App → define trigger → add action → deploy/test."
    },
    {
      "id": 290,
      "domain": "Storage",
      "question": "Case Study: An IoT solution writes sensor data to Cosmos DB. Queries must be globally consistent.\n\nWhich consistency level should be used?",
      "options": [
        "A) Strong",
        "B) Session",
        "C) Eventual",
        "D) Bounded staleness"
      ],
      "multi_select": false,
      "hint": "Strongest guarantee possible.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Strong consistency ensures reads always return the most recent committed write."
    },
    {
      "id": 291,
      "domain": "Security",
      "question": "Case Study: A developer accidentally exposed a Function key in source control. How can you invalidate it quickly?",
      "options": [
        "A) Regenerate the Function key",
        "B) Rotate the storage account keys",
        "C) Re-deploy the function",
        "D) Disable the App Service plan"
      ],
      "multi_select": false,
      "hint": "Each function key can be regenerated individually.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Regenerating the Function key invalidates the compromised credential."
    },
    {
      "id": 292,
      "domain": "Compute",
      "question": "Arrange the steps to deploy a Docker image from ACR to AKS.",
      "options": [
        "A) az acr login",
        "B) kubectl create deployment",
        "C) az aks get-credentials",
        "D) kubectl expose deployment"
      ],
      "multi_select": false,
      "hint": "Authenticate registry → get credentials → deploy → expose.",
      "correct_answers": [
        "A",
        "C",
        "B",
        "D"
      ],
      "explanation": "Authenticate ACR, connect to AKS, deploy, then expose the service."
    },
    {
      "id": 293,
      "domain": "Integration",
      "question": "Case Study: You must send telemetry from an IoT gateway to Azure for analytics. Millions of messages per second are expected.\n\nWhich service should you use?",
      "options": [
        "A) Event Hubs",
        "B) Service Bus",
        "C) Event Grid",
        "D) Queue Storage"
      ],
      "multi_select": false,
      "hint": "Think big-data streaming.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Hubs supports massive, high-throughput streaming ingestion."
    },
    {
      "id": 294,
      "domain": "Monitoring",
      "question": "Case Study: You must trace dependencies and performance of an Azure Function calling a SQL Database. Which Application Insights feature provides this?",
      "options": [
        "A) Distributed Tracing",
        "B) Live Metrics",
        "C) Profiler",
        "D) Smart Detection"
      ],
      "multi_select": false,
      "hint": "Links telemetry across components.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Distributed tracing connects requests across services to visualize end-to-end latency."
    },
    {
      "id": 295,
      "domain": "Security",
      "question": "Arrange the steps to store a connection string securely in Key Vault and use it in an App Service.",
      "options": [
        "A) Add connection string as a secret in Key Vault",
        "B) Assign Key Vault Secrets User role to App Service identity",
        "C) Reference the secret using @Microsoft.KeyVault syntax",
        "D) Restart App Service"
      ],
      "multi_select": false,
      "hint": "Secret → permission → reference → refresh.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Add secret → grant identity access → reference → restart for environment variable load."
    },
    {
      "id": 296,
      "domain": "Compute",
      "question": "Case Study: A video-processing service requires GPU support for encoding tasks.\n\nWhich compute service should you use?",
      "options": [
        "A) Azure Kubernetes Service with GPU node pool",
        "B) Azure Container Instances",
        "C) Azure Functions",
        "D) App Service"
      ],
      "multi_select": false,
      "hint": "Only one supports GPU node types.",
      "correct_answers": [
        "A"
      ],
      "explanation": "AKS supports GPU-enabled VM sizes within node pools for compute-intensive workloads."
    },
    {
      "id": 297,
      "domain": "Storage",
      "question": "Arrange the steps to configure replication for a Storage Account to enable geo-redundancy.",
      "options": [
        "A) Navigate to the Storage Account",
        "B) Select 'Configuration'",
        "C) Change replication type to GRS or RA-GRS",
        "D) Save configuration"
      ],
      "multi_select": false,
      "hint": "Configuration > replication type > save.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Replication type changes under Configuration, then save to enable geo-redundancy."
    },
    {
      "id": 298,
      "domain": "Integration",
      "question": "Case Study: You must design a retry-resilient event-driven architecture. Events must be persisted until a subscriber confirms receipt.\n\nWhich service provides this behavior?",
      "options": [
        "A) Event Grid with dead-letter destination",
        "B) Event Hubs",
        "C) Logic Apps",
        "D) Service Bus"
      ],
      "multi_select": false,
      "hint": "Look for delivery attempts + DLQ support.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid retries events and stores undeliverable ones in a dead-letter destination for reliability."
    },
    {
      "id": 299,
      "domain": "Security",
      "question": "Case Study: Your application uses a managed identity to access Azure SQL Database. What must be configured on the SQL side?",
      "options": [
        "A) CREATE USER [<identity-name>] FROM EXTERNAL PROVIDER",
        "B) Enable Transparent Data Encryption",
        "C) Create login with password",
        "D) Configure connection string with SQL authentication"
      ],
      "multi_select": false,
      "hint": "Uses Azure AD authentication for identity.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The T-SQL command creates an AAD-based user for the managed identity."
    },
    {
      "id": 300,
      "domain": "Compute",
      "question": "Arrange the steps to deploy a Function App using GitHub Actions.",
      "options": [
        "A) Add publish profile secret in GitHub",
        "B) Create workflow using Azure Functions template",
        "C) Commit and push changes to main branch",
        "D) Verify deployment in Azure portal"
      ],
      "multi_select": false,
      "hint": "Secret → workflow → commit → verify.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Store publish profile, configure workflow, trigger deployment via commit, then verify in portal."
    },
    {
      "id": 301,
      "domain": "Integration",
      "question": "Case Study: A retail system needs to notify multiple downstream services when a product is updated. Notifications must be near real time and support multiple subscribers.\n\nWhich Azure service best fits?",
      "options": [
        "A) Event Grid",
        "B) Event Hubs",
        "C) Service Bus",
        "D) Logic Apps"
      ],
      "multi_select": false,
      "hint": "Think lightweight pub/sub for events.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid offers lightweight, near-real-time event distribution to multiple subscribers."
    },
    {
      "id": 302,
      "domain": "Compute",
      "question": "Arrange the correct steps to configure Application Insights for an Azure Function.",
      "options": [
        "A) Create an Application Insights resource",
        "B) Link it to the Function App via instrumentation key or connection string",
        "C) Enable Application Insights under Monitoring",
        "D) Validate telemetry in the portal"
      ],
      "multi_select": false,
      "hint": "Create → link → enable → verify.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Application Insights must be created, linked, enabled, and then validated to confirm telemetry flow."
    },
    {
      "id": 303,
      "domain": "Security",
      "question": "Case Study: You must protect secrets for an Azure Container App that connects to Cosmos DB. You want to avoid hardcoding credentials.\n\nWhat should you configure?",
      "options": [
        "A) Managed Identity + Key Vault references",
        "B) Environment variables with plain text connection strings",
        "C) Shared Access Keys in source code",
        "D) Application Settings in plaintext"
      ],
      "multi_select": false,
      "hint": "Use identity + externalized secrets.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Managed identity allows the container to authenticate to Key Vault and fetch secrets securely."
    },
    {
      "id": 304,
      "domain": "Monitoring",
      "question": "Case Study: You need to automatically restart a Function App when memory usage exceeds 80% for 10 minutes.\n\nWhat should you configure?",
      "options": [
        "A) Autoscale rule with custom metric condition",
        "B) Action group with restart webhook",
        "C) Logic App scheduled restart",
        "D) Diagnostic setting"
      ],
      "multi_select": false,
      "hint": "Alerts can trigger webhooks or automation.",
      "correct_answers": [
        "B"
      ],
      "explanation": "An action group can trigger a webhook or automation runbook to restart the app based on metric conditions."
    },
    {
      "id": 305,
      "domain": "Storage",
      "question": "Arrange the steps to connect an Azure Function to Cosmos DB using the binding model.",
      "options": [
        "A) Add Cosmos DB binding in function.json",
        "B) Specify database and collection name",
        "C) Add connection string in settings",
        "D) Implement binding logic in the Function code"
      ],
      "multi_select": false,
      "hint": "Binding configuration first, then code.",
      "correct_answers": [
        "C",
        "A",
        "B",
        "D"
      ],
      "explanation": "Add the connection string, configure bindings, specify targets, then use them in code."
    },
    {
      "id": 306,
      "domain": "Compute",
      "question": "Case Study: You need to process video uploads asynchronously. Each upload triggers a long-running encoding job.\n\nWhich Azure service combination is best?",
      "options": [
        "A) Blob Storage + Event Grid + Durable Functions",
        "B) Blob Storage + Service Bus + Logic Apps",
        "C) Event Hubs + Stream Analytics",
        "D) Container Apps + Timer Triggers"
      ],
      "multi_select": false,
      "hint": "Think event-driven orchestration for long-running workflows.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid triggers Durable Functions that coordinate long-running encoding workflows."
    },
    {
      "id": 307,
      "domain": "Integration",
      "question": "Arrange the steps to publish an Event Grid schema for custom events.",
      "options": [
        "A) Define event schema in JSON",
        "B) Create a custom topic",
        "C) Publish event using schema to topic endpoint",
        "D) Verify event delivery to subscriber"
      ],
      "multi_select": false,
      "hint": "Define schema → create → publish → verify.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Event Grid custom events follow a defined schema published to a custom topic and verified on delivery."
    },
    {
      "id": 308,
      "domain": "Security",
      "question": "Case Study: You’re deploying a multi-tenant web app using Azure AD for authentication. Each tenant must sign in with their own directory.\n\nWhich Azure AD option should you use?",
      "options": [
        "A) Multi-tenant app registration",
        "B) Single-tenant app registration",
        "C) Guest user invitations",
        "D) External Identities"
      ],
      "multi_select": false,
      "hint": "Allows other AAD tenants to authenticate.",
      "correct_answers": [
        "A"
      ],
      "explanation": "A multi-tenant registration enables authentication from multiple Azure AD directories."
    },
    {
      "id": 309,
      "domain": "Integration",
      "question": "Case Study: An order system must trigger workflows when messages are added to a Service Bus queue. Reliability is critical.\n\nWhich trigger type should your Function App use?",
      "options": [
        "A) Service Bus trigger",
        "B) Event Grid trigger",
        "C) HTTP trigger",
        "D) Queue Storage trigger"
      ],
      "multi_select": false,
      "hint": "Guaranteed delivery and retries.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Service Bus trigger ensures at-least-once delivery and supports dead-letter handling."
    },
    {
      "id": 310,
      "domain": "Monitoring",
      "question": "Arrange the steps to enable logging for an Azure API Management instance.",
      "options": [
        "A) Create Log Analytics workspace",
        "B) Link API Management to the workspace",
        "C) Enable diagnostic logs",
        "D) Query logs using KQL"
      ],
      "multi_select": false,
      "hint": "Create → link → enable → query.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "You must link API Management to a workspace, enable logs, then use KQL to analyze them."
    },
    {
      "id": 311,
      "domain": "Storage",
      "question": "Case Study: You need to restore accidentally deleted blobs from the last 7 days.\n\nWhich feature enables this?",
      "options": [
        "A) Soft delete",
        "B) Versioning",
        "C) Lifecycle policies",
        "D) Snapshot restore"
      ],
      "multi_select": false,
      "hint": "Prevents permanent deletion.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Soft delete retains deleted blobs for a defined period allowing restore."
    },
    {
      "id": 312,
      "domain": "Compute",
      "question": "Arrange the steps to deploy a Container App that pulls images from a private Azure Container Registry.",
      "options": [
        "A) Enable managed identity for Container App",
        "B) Assign AcrPull role on registry",
        "C) Deploy container with image reference",
        "D) Test container startup"
      ],
      "multi_select": false,
      "hint": "Identity first, permissions second, deploy third.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Identity authenticates to ACR, role grants access, then deployment and validation occur."
    },
    {
      "id": 313,
      "domain": "Security",
      "question": "Case Study: An App Service needs to connect to Azure SQL using Managed Identity. What’s the correct connection string format?",
      "options": [
        "A) Server=tcp:<server>.database.windows.net;Authentication=Active Directory Managed Identity;",
        "B) Server=tcp:<server>.database.windows.net;UID=<MI_ID>;PWD=;",
        "C) Server=<server>;User=sa;Password=<key>",
        "D) Data Source=<server>;Integrated Security=True"
      ],
      "multi_select": false,
      "hint": "AAD-based connection string.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Using 'Authentication=Active Directory Managed Identity' enables AAD authentication for the managed identity."
    },
    {
      "id": 314,
      "domain": "Integration",
      "question": "Arrange the correct order to publish an API via API Management.",
      "options": [
        "A) Create API Management instance",
        "B) Import API definition (OpenAPI)",
        "C) Configure policies and products",
        "D) Publish and test API"
      ],
      "multi_select": false,
      "hint": "Create → import → configure → publish.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "APIM workflow follows creation, import, configuration, and publication."
    },
    {
      "id": 315,
      "domain": "Compute",
      "question": "Case Study: You must perform background jobs periodically without using an HTTP trigger. Which Function trigger fits best?",
      "options": [
        "A) Timer trigger",
        "B) Queue trigger",
        "C) Event Grid trigger",
        "D) Blob trigger"
      ],
      "multi_select": false,
      "hint": "Used for scheduled executions.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Timer triggers allow scheduled, non-HTTP execution of background tasks."
    },
    {
      "id": 316,
      "domain": "Monitoring",
      "question": "Case Study: You must create a dashboard showing App Service CPU usage and Function invocation count.\n\nWhich tool combines both metrics?",
      "options": [
        "A) Azure Workbooks",
        "B) Metrics Explorer",
        "C) Power BI",
        "D) Log Analytics only"
      ],
      "multi_select": false,
      "hint": "Custom visual dashboarding across sources.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Azure Workbooks allow combining visualizations from multiple metric sources."
    },
    {
      "id": 317,
      "domain": "Integration",
      "question": "Case Study: An e-commerce solution must publish order events to downstream microservices. Message delivery order is not important, but low latency is.\n\nWhich service should you choose?",
      "options": [
        "A) Event Grid",
        "B) Service Bus",
        "C) Event Hubs",
        "D) Storage Queue"
      ],
      "multi_select": false,
      "hint": "Event-driven, not message queue.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid provides lightweight, near-real-time event distribution for loosely coupled systems."
    },
    {
      "id": 318,
      "domain": "Compute",
      "question": "Arrange the steps to deploy a Python Function App using VS Code.",
      "options": [
        "A) Install Azure Functions extension",
        "B) Create a new Function project",
        "C) Choose Python runtime",
        "D) Deploy to Azure from VS Code"
      ],
      "multi_select": false,
      "hint": "Extension → project → runtime → deploy.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "The extension guides project creation, runtime selection, and deployment to Azure."
    },
    {
      "id": 319,
      "domain": "Security",
      "question": "Case Study: You need to restrict an App Service so only traffic from a Function App is allowed.\n\nWhat should you use?",
      "options": [
        "A) Virtual Network Integration + Private Endpoint",
        "B) Shared Access Signature",
        "C) CORS configuration",
        "D) IP restrictions only"
      ],
      "multi_select": false,
      "hint": "Enforce traffic inside a private network.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Using private endpoints and VNet integration ensures only internal traffic reaches the App Service."
    },
    {
      "id": 320,
      "domain": "Storage",
      "question": "Case Study: You must ingest IoT telemetry to Blob Storage for cold analytics, minimizing cost.\n\nWhich storage tier should you use?",
      "options": [
        "A) Cool",
        "B) Hot",
        "C) Archive",
        "D) Premium"
      ],
      "multi_select": false,
      "hint": "Infrequent access, long-term storage.",
      "correct_answers": [
        "A"
      ],
      "explanation": "The Cool tier offers cheaper storage for infrequently accessed data."
    },
    {
      "id": 321,
      "domain": "Monitoring",
      "question": "Arrange the steps to create an alert when Service Bus queue length exceeds 100 messages.",
      "options": [
        "A) Open Service Bus namespace",
        "B) Select 'Alerts' and create a rule",
        "C) Choose 'Active Messages' metric",
        "D) Define condition and action group"
      ],
      "multi_select": false,
      "hint": "Navigate → create → choose metric → define rule.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Alerts are configured at namespace level, selecting the queue metric and defining threshold/action."
    },
    {
      "id": 322,
      "domain": "Integration",
      "question": "Case Study: You must create a pipeline that reacts to events and pushes data into a Data Lake.\n\nWhich service combination is best?",
      "options": [
        "A) Event Grid + Data Factory",
        "B) Logic Apps + Service Bus",
        "C) Stream Analytics + Blob Storage",
        "D) Durable Functions + Cosmos DB"
      ],
      "multi_select": false,
      "hint": "Event triggers for orchestration.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid triggers Data Factory pipelines for automated ingestion."
    },
    {
      "id": 323,
      "domain": "Compute",
      "question": "Case Study: A Durable Function orchestrator must call an external API and wait for a callback.\n\nWhich pattern is this?",
      "options": [
        "A) External Events",
        "B) Fan-out/fan-in",
        "C) Chaining",
        "D) Async HTTP API"
      ],
      "multi_select": false,
      "hint": "Pause until signal is received.",
      "correct_answers": [
        "A"
      ],
      "explanation": "External Events pattern waits for a signal from an external source before resuming execution."
    },
    {
      "id": 324,
      "domain": "Security",
      "question": "Arrange the steps to assign an App Service access to Azure Storage using a system-assigned managed identity.",
      "options": [
        "A) Enable system-assigned identity on App Service",
        "B) Assign Storage Blob Data Contributor role",
        "C) Add connection using identity authentication",
        "D) Validate access by reading blob"
      ],
      "multi_select": false,
      "hint": "Enable → assign → connect → test.",
      "correct_answers": [
        "A",
        "B",
        "C",
        "D"
      ],
      "explanation": "Enable identity, grant role, connect using identity-based auth, then validate access."
    },
    {
      "id": 325,
      "domain": "Monitoring",
      "question": "Case Study: You must collect logs from multiple Function Apps into one central workspace.\n\nWhich feature supports this?",
      "options": [
        "A) Diagnostic settings to a shared Log Analytics workspace",
        "B) Separate Application Insights instances",
        "C) Export logs to Blob storage",
        "D) Local file system logs"
      ],
      "multi_select": false,
      "hint": "Centralize logging in one workspace.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Diagnostic settings allow multiple resources to forward logs to a single shared workspace."
    },
    {
      "id": 326,
      "domain": "Compute",
      "question": "Arrange the steps to scale out a Function App using Azure CLI.",
      "options": [
        "A) az functionapp plan update --number-of-workers 3",
        "B) az functionapp list",
        "C) Verify scaling via Metrics Explorer",
        "D) Save configuration"
      ],
      "multi_select": false,
      "hint": "Update plan → verify in metrics.",
      "correct_answers": [
        "B",
        "A",
        "D",
        "C"
      ],
      "explanation": "List app, update worker count, save configuration, and verify via metrics."
    },
    {
      "id": 327,
      "domain": "Storage",
      "question": "Case Study: You need to detect when new blobs are added to a container and start a workflow.\n\nWhich service combination should you use?",
      "options": [
        "A) Event Grid + Logic Apps",
        "B) Blob Lifecycle Management",
        "C) Event Hubs + Stream Analytics",
        "D) Storage Analytics logs"
      ],
      "multi_select": false,
      "hint": "Push-based trigger to orchestrator.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Event Grid triggers Logic Apps or Functions upon blob creation."
    },
    {
      "id": 328,
      "domain": "Integration",
      "question": "Arrange the steps to configure retry and dead-letter behavior for a Service Bus queue.",
      "options": [
        "A) Define MaxDeliveryCount",
        "B) Enable dead-lettering on message expiration",
        "C) Configure queue properties in portal",
        "D) Test by sending messages"
      ],
      "multi_select": false,
      "hint": "Properties before testing.",
      "correct_answers": [
        "C",
        "A",
        "B",
        "D"
      ],
      "explanation": "Queue properties define retries and DLQ; testing validates configuration."
    },
    {
      "id": 329,
      "domain": "Compute",
      "question": "Case Study: You must host an API in a container, expose it via HTTPS, and integrate with Azure AD for authentication.\n\nWhich service combination fits best?",
      "options": [
        "A) Azure App Service for Containers + Azure AD authentication",
        "B) Azure Container Instances + custom SSL setup",
        "C) AKS with manual NGINX Ingress",
        "D) Azure Functions with HTTP trigger"
      ],
      "multi_select": false,
      "hint": "Easiest managed hosting with built-in auth.",
      "correct_answers": [
        "A"
      ],
      "explanation": "App Service for Containers provides HTTPS endpoints, scaling, and built-in Azure AD integration."
    },
    {
      "id": 330,
      "domain": "Security",
      "question": "Case Study: You must ensure that all Function Apps in a subscription use HTTPS only and block public HTTP.\n\nWhich approach enforces this at scale?",
      "options": [
        "A) Azure Policy requiring 'httpsOnly' property set to true",
        "B) Enabling HTTPS manually on each Function App",
        "C) Web.config redirect rule",
        "D) Application Gateway rewrite rules"
      ],
      "multi_select": false,
      "hint": "Governance at subscription level.",
      "correct_answers": [
        "A"
      ],
      "explanation": "Azure Policy enforces the 'httpsOnly' configuration across all Function Apps for compliance."
    }
  ]
}